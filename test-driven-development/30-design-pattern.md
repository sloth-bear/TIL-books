

* 이 책은 설계를 독립된 단계로 바라보는 성향을 어렴풋이 띤다.
* 이 책은 확실히 리팩토링을 설계의 일종으로 보는 것에 동의하지 않는다. 
* TDD에서는 설계를 디자인 패턴과는 조금 다른 관점으로 본다. 
    * 디자인 패턴에서는 설계를 어떻게 보는가?

* Use of Design Patterns in TDD
    |      **Pattern**     | **Test Writing** | **Refactoring** |
    |:--------------------:|:----------------:|:---------------:|
    | Command              |         X        |                 |
    | Value Object         |         X        |                 |
    | Null Object          |                  |        X        |
    | Template Method      |                  |        X        |
    | Pluggable Object     |                  |        X        |
    | Pluggable Selector   |                  |        X        |
    | Factory Method       |         X        |        X        |
    | Imposter             |         X        |        X        |
    | Composite            |         X        |        X        |
    | Collecting Parameter |         X        |        X        |

# 리팩토링이란?
* 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법
* 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다
* 즉, 리팩터링하기 전과 후의 코드는 똑같이 동작해야 한다. 그 과정에서 성능이 변할 수 있지만, 결국 사용자 관점에서는 달라지는 점이 없어야 한다. 물론 리팩터링 과정에서 발견된 버그는 리팩터링 후에도 그대로 남아 있어야 한다. 
* Two hats: '기능 추가' 모자와 '리팩터링' 모자 (Kent back)
    * 기능 추가: 기존 코드는 절대 건드리지 않고 새 기능을 추가하기만 한다. 
    * 리팩터링: 기능 추가는 절대 하지 않기로 다짐한 뒤 오로지 코드 재구성에만 전념한다. 테스트도 새로 만들지 않는다. 부득이 인터페이스를 변경해야 할 때만 기존 테스트를 수정한다.
    * 새 기능을 추가하다 보면 코드 구조를 바꿔야 작업하기 훨씬 쉽겠다는 생각이 들 때도 있다. 그러면 잠시 모자를 바꿔 쓰고 리팩터링한다. 


# 리팩터링하는 이유
* 리팩터링은 모든 문제점을 해결하는 만병통치약은 절대 아니다. 하지만 코드를 건강한 상태로 유지하는 데 도와주는 약임은 분명하다. 

## 1. 소프트웨어 설계가 좋아진다.
* 리팩터링을 하지 않으면 소프트웨어의 내부 설계(아키텍쳐)가 썩기 쉽다. 코드만 봐서는 설계를 파악하기 어려워진다. 코드만으로 설계를 파악하기 어려워질수록 설계를 유지하기 어려워지고, 설계가 부패되는 속도는 더욱 빨라진다. 반면 규칙적인 리팩터링은 코드의 구조를 지탱해줄 것이다. 

* 같은 일을 하더라도 설계가 나쁘면 코드가 길어지기 십상이다. 사실상 같은 일을 하는 코드가 여러 곳에 나타날 수 있기 때문이다. 그래서 중복 코드 제거는 설계 개선 작업의 중요한 한 축을 차지한다. 코드량이 준다고 해서 시스템이 빨라지는 것은 아니지만 수정하는 데 드는 노력은 크게 달라진다. 코드가 길수록 실수 없이 수정하기 어려워진다. 비슷한 일을 하는 코드가 산재해 있다면 한 부분만 살짝 바꿔서는 시스템이 예상대로 작동하지 않을 수 있다. 반면에, 중복 코드를 제거하면 모든 코드가 언제나 고유한 일을 수행함을 보장할 수 있고 이는 바람직한 설계의 핵심이다. 바람직한 설계는 바꾸기 쉽다. DRY, 그리고 ETC.


## 2. 소프트웨어를 이해하기 쉬워진다. 
* 


## 3. 버그를 쉽게 찾을 수 있다. 

## 4. 프로그래밍 속도를 높일 수 있다. 


# 언제 리팩토링해야 할까?
* 코드의 중복
* 길어진 메서드 
* 길어진 파라미터 목록
* 부적절한 네이밍 


----
# Refactoring IN TDD
## 정의
TDD에서는 리팩토링을 특이한 방식으로 사용한다. 리팩토링은 프로그램의 의미`semantics of the program`를 바꾸면 안 된다. 바꿀 수 없다. 어떤 상황에서도 말이다. TDD에서 신경 쓰는 이 '어떤 상황들'은 이미 통과한 테스트들이다. 

예를 들어 이러한 테스트케이스가 있다. 우리는 초록막대를 보아야 한다.
```java
@Test
public void addTest() {
    //...
    assertThat(addCommand.execute(5, 3))
      .isEqualTo(8);
}
```

상수로 구현함으로써 테스트케이스는 통과하였다.
```java
public int execute(int x, int y) {
    return 8;
}
```

여기서 리팩토링을 시도한다. 이 메서드의 semantic은 변하였을까?
```java
public int execute(int x, int y) {
    return 5 + 3;
}
```

이렇게 바꾼다면?
```java
public int execute(int x, int y) {
    return x + y;
}
```

이제 나머지 테스트들은 실패할 수도 있겠다. 좀 전의 테스트 케이스가 아래와 같았다면 말이다. 
```java
@Test
public void addTest() {
    //...
    assertThat(addCommand.execute(5, 3))
      .isEqualTo(8);

    assertThat(addCommand.execute(1, 4))
      .isEqualTo(8);
}
```

그러나 TDD에서는 그러한 나머지 테스트들은 "아직 만들지 않았기" 때문에 걱정할 필요가 없다고 이야기한다. 이 addTest가 정말 검증하고 싶은 것은 주어진 두 개의 파라미터의 합이기 때문이다. 
즉, 테스트케이스가 충분하지 않았음을 이야기한다. 추측 가능한 모든 테스트가 작성되지 않았던 것이다. 예를 들면 아래와 같이 말이다. 
```java
@Test
public void addTest() {
    //...
    assertThat(addCommand.execute(5, 3)).isEqualTo(8);
    assertThat(addCommand.execute(1, 4)).isEqualTo(5);
}
```

이렇게 관측상의 동치성`observational equivalence`이 성립되려면 <b>충분한 테스트</b>가 필요하다. 


## Skills
### 차이점 일치시키기`Reconcile Differences`
* DRY!

* 유사해보이는 두 코드 조각을 합치려면 그 코드들을 차츰 닮아가게끔 해야 한다. 그리고 그 두 코드가 "완전히 동일할 때"만 통합한다. 

* 비약적인 리팩토링은 피해야 한다. 우리의 전략은 작은 단계`small steps`와 구체적인 피드백`concrete feedback`이기 때문이다. 비약적인 리팩토링은 지금 고치려고 하는 부분이 결과에 영향을 주지 않을 거라고 믿게 한다. 이러한 비약적인 리팩토링을 늘 피할 순 없겠지만 발생 빈도는 줄일 수 있다. 

* 이 리팩토링은 모든 규모의 작업에서 발생한다. 
  * 두 반복문`loop`이 유사하다. -> 동일하게 만든 후, 병합한다.
  * 조건문`conditional`의 두 가지 분기문이 비슷하다. -> 동일하게 만들고, 조건문을 제거한다.
  * 두 메소드`method`가 유사하다. -> 동일하게 만든 후, 하나를 제거한다.
  * 두 클래스`class`가 유사하다. -> 동일하게 만든 후, 제거한다. 


### 변화 격리하기`Isolate Change`
* 메서드나 클래스의 여러 부분 중에 한 부분만 변경하고 싶을 경우 -> 해당 파트를 격리한다.

* 격리한 후 바꾸고 나면, 작업을 되돌리기도 매우 수월해진다. 

* 격리하기 위한 방법에는 아래와 같은 것들이 있다. 
  * 메서드 추출하기`Extract Method` (가장 일반적이다.)
  * 객체 추출하기`Extract Object`
  * 메서드 객체`Method Object`


### 데이터 이주시키기`Migrate Data`
* 데이터가 표시되는 방식을 변경하고자 함에 있어, 표현 양식`representation`을 어떻게 바꿀까? -> 일시적으로 데이터를 중복시킨다. 

* one -> many일 때 이런 문제가 자주 발생한다.

#### 방법
* 내부 -> 외부`internal-to-external`로 변경하려면 이렇게 한다. 내부의 표현 양식을 우선 변경하고, 보여지는 외부 인터페이스를 변경한다. 
  1. 새로운 포맷의 인터페이스 변수 추가
  2. 예전 포맷에서 set하던 모든 부분에 새로운 포맷의 변수를 set한다.
  3. 예전 포맷의 변수 대신 새로운 포맷의 변수를 사용한다. 
  4. 예전 포맷의 변수를 삭제한다. 
  5. 외부 인터페이스를 새 포맷에 맞게 변경한다. 

* 종종 외부 interface부터 바꿔야 할 때`API first`는 이렇게 한다.
  1. 새 포맷의 파라미터를 추가한다. 
  2. 새 포맷 파라미터에서 예전 포맷의 내부 표현 양식으로 바꾼다. (?)
  3. 예전 포맷 파라미터를 삭제한다. 
  4. 예전 포맷을 사용하던 곳을 새 포맷으로 대체한다. 
  5. 예전 포맷은 삭제한다.


### 메서드 추출하기`Extract Method`
* 길어지고, 복잡해진 메서드를 어떻게 읽기 쉽게 바꿀까? 메서드를 작게 분리해 그를 호출하게 하라.

* 메서드 추출은 사실 조금 더 복잡한 원자적`atomic` 리팩토링 중 하나다. 전형적인 예는 아래와 같다. 
  - 기존의 메서드에서 분리할 수 있을 만한 부분 찾기
    ex) 반복문 내부 코드, 반복문 전체, 조건문의 가지들 
  - 추출할 영역 scope 외부에 선언된 임시 변수에 대한 할당이 있는지 확인
  - 새로운 메소드로 복사 
  - 기존 메서드의 임시변수나 파라미터가 새 메서드에도 사용되면 추가해주기
  - 새 메서드를 기존 메서드에서 call

* 해당 기능은 tool에서 많이들 지원해준다. 

* 복잡한 코드에 대한 이해

* 중복 제거 

* 때로 그 정도가 지나칠 수도 있어서 더 나아갈 방법이 보이지 않으면 메서드 인라인해서 다시 확인


### 메서드 인라인`Inline Method`
* 너무 꼬여있거나, 산재되어있는 흐름을 단순하게 제어하고 싶을 때 사용 

* 분리된 메서드를 해당 메서드 본문으로 교체하면 된다. 
  - 메서드 복사
  - 메서드 호출 부분에 해당 메서드를 붙여넣기 
  - formal parameter를 actual parameter로 교체 


### 인터페이스 추출하기`Extract Interface`
* Java Operation에 대한 2번째 구현체를 만들고자 한다면? 공통되는 operation을 포함하는 interface를 생성하라.
  - 인터페이스 선언 (기존 클래스와 이름이 같을 경우 기존 클래스의 이름을 변경하고 선언)
  - 기존 클래스가 인터페이스를 구현하도록 수정 
  - 인터페이스에 필수 메서드 추가, 필요하다면 클래스에 존재하는 메서드들의 가시성 확장 
  - 가능한 모든 곳의 타입 선언부에서 클래스 이름 대신 인터페이스 이름 사용하게 변경 


### 메서드 옮기기`Move Method`
* 메서드를 원래 있어야 할 곳으로 옮기려면? 어울리는 클래스에 메서드를 추가해주고, 그것을 호출하게 하라
  - 메서드 복사 
  - 원하는 클래스에 메서드 붙여넣기, 컴파일
  - 기존 객체가 메서드 내에서 참조된다면 메서드에 파라미터로 추가하기, 필드들이 참조되고 있다면 마찬가지로 추가하기 (만약 기존 객체의 필드들이 갱신된다면 포기할 것)
  - 기존 메서드 body는 지우고 새 메서드 호출하도록 수정 

* 한 메서드에서 다른 객체에 하나 이상의 메시지를 보내는 것을 보면 의심 

* 장점은 아래와 같다. 
  - 코드의 의미를 깊이 이해하지 않고도 코드의 필요성을 


### 메서드 객체`Method Object`
* 여러 개의 매개 변수와 지역 변수를 갖는 복잡한 메서드를 어떻게 표현할까? 메서드를 꺼내 클래스로 만든다. 
  - 같은 파라미터들을 갖는 클래스 생성
  - 메서드의 지역 변수를 클래스 내 인스턴스 변수로 생성
  - run() 메서드를 하나 만들고, method body는 기존 method와 동일하게 변경 
  - 기존 메서드에서 해당 클래스의 run() 메서드 호출 


### 매개변수 추가`Add Parameter`
* 메서드에 파라미터를 추가하려면?
  - 메서드가 interface 내에 있다면, interface에 파라미터를 먼저 추가
  - 파라미터 추가 
  - compile error를 확인하며 수정 

* 확장 단계인 것을 의미할 때가 있음 


### 메서드 매개변수를 생성자 매개변수로 바꾸기`Method Parameter to Constructor Parameter`
* 메서드 파라미터를 어떻게 생성자 파라미터로 바꿀까? 
  - 생성자에 파라미터 추가 
  - 파라미터와 같은 이름의 인스턴스 변수 추가 
  - 생성자에서 변수 set
  - `parameter`를 하나씩 `this.parameter`로 바꾸기
  - 파라미터에 대한 참조가 더 이상 없으면, 해당 파라미터를 메서드와 모든 호출자에서 제거 
  - this 제거 (꼭 제거해야 되나?)
  - 변수명 적절히 변경 

* 동일한 파라미터를 같은 객체의 서로 다른 몇몇 메서드로 전달하는 경우라면 파라미터를 한 번만 전달하게끔 API를 단순화할 수 있다. (DRY!!) 만약 인스턴스 변수가 오직 하나의 메서드에서만 쓰이는 경우라면 이 리팩터링을 반대로 수행할 수도 있다. (생성자 to 메서드)


# References
[What does migrate data on TDD mean?](https://stackoverflow.com/questions/11295385/what-does-migrate-data-on-tdd-mean)
[SOLID principles](https://www.baeldung.com/solid-principles)