# Today I Learned
| 구분  | 내용             |
|------|-----------------|
| DATE | 2022.06.04      |
| PART | 1. What happens |


# What Happens
이 장에서는 자바에 포함된 함수형 프로그래밍의 핵심적인 두 아이디어를 살펴본다. 
* 메서드와 람다를 일급값으로 사용함
* 가변 공유 상태가 없는 병렬 실행을 이용해서 효율적이고 안전하게 함수나 메서드를 호출할 수 있음


## Index
* [역사의 흐름](#역사의-흐름) - 자바가 멀티코어 병렬성을 더 쉽게 이용할 수 있도록 진화하는 과정과 관련 개념
* [왜 아직도 자바는 변화하는가?](#왜-아직도-자바는-변화하는가) - 자바 8에서 제공하는 코드를 메서드로 전달하는 기법이 어떻게 강력한 새로운 프로그래밍 도구가 될 수 있는지 
* [Java function](#java-function) - 스트림 API(병렬형 데이터를 표현하고 이들 데이터를 병렬로 처리할 수 있음을 유연하게 보여주는)가 어째서 강력하고 새로운 프로그래밍 도구인지 
* [Stream](#stream) - default method라는 새로운 자바 8의 기능을 인터페이스, 라이브러리의 간결성 유지 및 재컴파일을 줄이는 데 어떻게 활용할 수 있는지 
* [Default method and java module](#default-method-and-java-module) - JVM을 구성하는 자바 및 기타 언어에서 함수형 프로그래밍이라는 존재가 어떤 영향을 미치는지 


## 무슨 일이 일어나고 있는가?
### 역사의 흐름
* 자바 역사를 통틀어 가장 큰 변화가 자바 8에서 일어났다. 자바 9에서도 중요한 변화가 있엇다. 하지만 곧 책에서 살펴볼 수 있듯이 잡 8만큼 획기적이거나 생산성이 바뀌는 것은 아니다. 자바 10에서는 형 추론과 관련해 약간의 변화만 일어났다. 이런 크고 작은 변화 덕분에 프로그램을 더 쉽게 구현할 수 있게 되었다. 

* 멀티코어 CPU 대중화와 같은 하드웨어적인 변화도 자바 8에 영향을 미쳤다. 여러분이 사용하는 랩톱이나 데스크톱에는 아마 듀얼 혹은 쿼드 코어 이상을 지원하는 CPU가 내장되어 있을 것이다. 지금까지의 대부분의 자바 프로그램은 코어 중 하나만을 사용했다(즉, 나머지 코어는 유휴 idle 상태로 두거나, 운영체제나 바이러스 검사 프로그램과 프로세스 파워를 나눠서 사용했다.)

* 자바 8이 등장하기 이전에는 나머지 코어를 활요하려면 스레드를 사용하는 것이 좋다고 누군가가 조언했을 것이다. 하지만 스레드를 사용하면 관리하기 어렵고 많은 문제가 발생할 수 있다는 단점이 있다. 자바는 이러한 병렬 실행 환경을 쉽게 관리하고 에러가 덜 발생하는 방향으로 진화하려 노력했다. 자바 1.0에서는 스레드와 lock, 심지어 메모리 모델까지 지원햇다. 당시로서는 최상의 선택이었을지도 모르지만, 특별 전문가로 구성된 프로젝트팀이 아닌 한 이와 같은 저수준 기능을 온전히 활용하기 어려웠다. 자바 5에서는 스레드 풀`thread pool`, 병렬 실행 컬렉션`concurrent collection` 등 아주 강력한 도구를 도입했다. 자바 7에서는 병렬 실행에 도움을 줄 수 있는 포크/조인 프레임워크를 제공했지만 여전히 개발자가 활용하기는 쉽지 않았다. 자바 8에서는 병렬 실행을 새롭고 단순한 방식으로 접근할 수 있는 방법을 제공한다. 

* 자바 8은 간결한 코드, 멀티코어 프로세서의 쉬운 활용이라는 두 가지 요구사항을 기반으로 한다. 일단 자바 8에서 제공하는 새로운 기술이 어떤 것인지 확인하자. 
  - 스트림 API - 병렬 연산 지원
    + 데이터베이스 질의 언어에서 고수준 언어로 원하는 동작을 표현하면, 구현(자바에서는 스트림 라이브러리가 이 역할을 수행)에서 최적의 저수준 실행방법을 선택하는 방식으로 동작한다. 즉, 스트림을 이용하면 에러를 자주 일으키며 멀티코어 CPU를 이용하는 것보다 비용이 훨씬 비싼 키워드 `synchronized`를 사용하지 않아도 된다. 
    + 조금 다른 관점에서 보면 결국 자바 8에 추가된 스트림 API 덕분에 다른 두 가지 기능, 즉 메서드에 코드를 전달하는 간결 기법(method reference, lambda)과 인터페이스의 default method가 존재할 수 있음을 알 수 있다. 
    + 그러나 스트림 API 때문에 메서드에 코드를 전달하는 기법이 생겼다고 생각하는 것은 메서드를 전달하는 기법의 활용성을 제한할 수 있다. 메서드에 코드를 전달하는 기법을 이용하면 새롭고 간결한 방식으로 동작 파라티머화`behavior parameterization`를 구현할 수 있다. 
  - 메서드에 코드를 전달하는 기법
  - 인터페이스의 디폴트 메서드 

* 자바 8 기법은 `functional programming`에서 위력을 발휘한다. 

* 자바 9에서는 리액티브 프로그래밍이라는 병렬 실행 기법을 지원한다. 이 기법을 사용할 수 있는 상황은 한정되어 있지만 요즘 수요가 많은 고성능 병렬 시스템에서 특히 인기를 얻고 있는 `RcJava`(리액티브 스트림 툴킷이라고도 불림)를 표준적인 방식으로 지원한다. 


### 왜 아직도 자바는 변화하는가?
* 자바는 출발이 좋았다. 즉, 처음부터 많은 유용한 라이브러리를 포함하는 잘 설계된 객체지향 언어로 시작했다. 자바는 처음부터 스레드와 락을 이용한 소소한 동시성도 지원했다(자바의 하드웨어 중립젹인 메모리 모델 때문에 멀티코어 프로세서에서 병렬적으로 수행되는 스레드는 싱글코어에서의 동작과 달리 예기치 못한 상황을 일으킬 수 있다.). 코드를 JVM 바이트 코드로 컴파일하는 특징(그리고 모든 브라우저에서 가상 머신 코드를 지우너하기) 때문에 자바는 인터넷 애플릿 프로그램의 주요 언어가 되었다. 

* 또한 자바는 다양한 임베디드 컴퓨팅 분야(스마트카드, 토스터, 셋톱박스, 자동차 브레이크 시스템 등)를 성공적으로 장악하고 있다. 

* 하지만 프로그래밍 언어 생태계에 변화의 바람이 불었다. 프로그래머는 빅데이터(테라바이트 이상의 데이터셋)라는 도전에 직면하면서 멀티코어 컴퓨터나 컴퓨팅 클러스터를 이용해서 빅데이터를 효과적으로 처리할 필요성이 커졌다. 즉, 병렬 프로세싱을 활용해야 하는 데 지금까지의 자바로는 충분히 대응할 수 없었다. 

* 자바 8은 더 다양한 프로그래밍 도구 그리고 다양한 프로그래밍 문제를 더 빠르고 정확하며 쉽게 유지보수할 수 있다는 장점을 제공한다. 잡 8에 추가된 기능은 자바에 없던 완전히 새로운 개념이지만 현재 시장에서 요구하는 기능을 효과적으로 제공한다. 

* 큰 시스템의 설계 방식도 환경 변화의 한 요소다. 최근에는 외부에서 큰 하위시스템 컴포넌트를 추가하고 다른 벤더가 만든 컴포넌트를 이용해 개발하는 사례가 늘어나고 있다. 자바 8, 자바 9에서는 이런 설계 스타일에 적응할 수 있도록 디폴트 메서드와 모듈을 제공한다. 

* 자바 8 설계의 밑바탕을 이루는 세 가지 프로그래밍 개념은 아래와 같다. 

#### 스트림 처리 
* 스트림이란 한 번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임이다. 이론적으로 프로그램은 입력 스트림에서 데이터를 한 개씩 읽어 들이며 마찬가지로 출력 스트림으로 데이터를 한 개씩 기록한다. 즉, 어떤 프로그램의 출력 스트림은 다른 프로그램의 입력 스트림이 될 수 있다. 일례로 유닉스나 리눅스의 많은 프로그램은 표준 입력(유닉스와 C의 `stdin`, 자바의 `System.in`)에서 <b>데이터를 읽은</b> 다음에, <b>데이터를 처리</b>하고, <b>결과를 표준 출력</b>(유닉스와 C의 `stdout`, 자바의 `System.out`)으로 기록한다. 

* 자바 8에는 `java.util.stream` 패키지에 스트림 API가 추가되었다. 스트림 API는 파이프라인을 만드는 데 필요한 많은 메서드를 제공한다.

* 스트림 API의 핵심은 기존에는 한 번에 한 항목을 처리했지만 이제 자바 8에서는 우리가 하려는 작업을 (데이터베이스 질의처럼) 고수준으로 추상화해서 일련의 스트림으로 만들어 처리할 수 있다는 것이다. 또한 스트림 파이프라인을 이용해서 입력 부분을 여러 CPU 코어에 쉽게 할당할 수 있다는 부가적인 이득도 얻을 수 있다. 스레드라는 복잡한 작업을 사용하지 않으면서도 공짜로 병렬성을 얻을 수 있다. 

#### 동작 파라미터화로 메서드에 코드 전달하기 
* 이는 코드 일부를 API로 전달하는 기능이다. 자바 8에서는 메서드(우리 코드)를 다른 메서드의 인수로 넘겨주는 기능을 제공한다. 이를 동작 파라미터화`behavior parameterization`라고 부른다. 동작 파라미터화가 왜 중요할까? 스트림 API는 연산의 동작을 파라미터화할 수 있는 코드를 전달한다는 사상에 기초하기 때문이다. 


#### 병렬성과 공유 가변 데이터
* 스트림 메서드로 전달하는 코드는 다른 코드와 동시에 실행하더라도 안전하게 실행할 수 있어야 한다. 보통 다른 코드와 동시에 실행하더라도 안전하게 실행할 수 있는 코드를 만들려면 공유된 가변 데이터`shared mutable data`에 접근하지 않아야 한다. 이러한 함수를 <b>순수`pure` 함수, 부작용 없는`side-effect-free` 함수, 상태 없는`stateless` 함수</b>라고 부른다.

* 지금까지는 독립적으로 실행될 수 있는 다중 코드 사본과 관련된 병렬성을 고려했다. 하지만 공유된 변수나 객체가 있으면 병렬성에 문제가 발생한다. 예를 들어 두 프로세스가 공유된 변수를 동시에 바꾸려 하면 어떻게 될까? 

* 물론 기존처럼 `syncronized`를 이용해서 공유된 가변 데이터를 보호하는 규칙을 만들 수 있을 것이다(일반적으로 `syncronized`는 시스템 성능에 악영향을 미친다.). 하지만 자바 8 스트림을 이용하면 기존의 자바 스레드 API보다 쉽게 병렬성을 활용할 수 있다. 다중 프로세싱 코어에서 `syncronized`를 사용하면 (다중 처리 코어에서는 코드가 순차적으로 실행되어야 하므로 병렬이라는 목적을 무력화시키면서) 생각보다 훨씬 더 비싼 대가를 치러야 할 수 있다. 

* 공유되지 않은 가변 데이터`no shared mutable data`, 메서드, 함수 코드를 다른 메서드를 전달하는 두 가지 기능은 <b>함수형 프로그래밍</b> 패러다임의 핵심적인 사항이다. 반면 <b>명령형 프로그래밍`imperative programming`</b> 패러다임에서는 일련의 가변 상태로 프로그램을 정의한다. 공유되지 않은 가변 데이터 요구사항이란 인수를 결과로 변환하는 기능과 관련된다. 즉, 이 요구사항은 수학적인 함수처럼 <b>함수가 정해진 기능만 수행</b>하며 (겉으로 보이는) <b>다른 부작용은 일으키지 않음</b>을 의미한다. 


#### 자바가 진화해야 하는 이유
* 지금까지 자바는 진화해왔다. 예를 들어 갑자기 제네릭`generic`이 나타나고, `List`가 `List<String>` 등으로 바뀌었을 때 당황했을 사람도 있었을 것이다. 하지만 맣은 이가 자바의 변화에 이미 익숙해져있으며, 그것이 가져다 주는 편리함(컴파일을 할 때 더 많은 에러를 검출할 수 있으며, 리스트의 유형을 알 수 있어 가독성도 좋아졌다.)을 누리고 있다. 

* 또 다른 변화의 예로, 틀에 박힌 `Iterator` 대신 `for-each` 루프를 사용할 수 있게 되었다. 기존 값을 변화시키는 데 집중했던 고전적인 객체지향에서 벗어나 함수형 프로그래밍으로 다가섰다는 것이 자바 8의 가장 큰 변화다. 함수형 프로그래밍에서는 우리가 하려는 작업(예를 들어 주어진 비용 이하로 A에서 B로 이동할 수 있는 모든 경로를 대표하는 값 생성)이 최우선시되며 그 작업을 어떻게 수행하는지(예를 들어 자료구조를 탐색하면서 컴포넌트를 수정함)는 별개의 문제로 취급한다. 

* 자바 8에서 함수형 프로그래밍을 도입함으로써 두 가지 프로그래밍 패러다임의 장점을 모두 활용할 수 있게 되었다. 즉, 어떤 문제를 효율적으로 해결할 수 있는 다양한 도구를 얻게 된 것이다. 

* 언어는 하드웨어나 프로그래머 기대의 변화에 부응하는 방향으로 변화해야 한다. 


### Java function
* 프로그래밍 언어에서 함수`function`라는 용어는 메서드`method` 특히 정적 메서드`static method`와 같은 의미로 사용된다. 자바의 함수는 이에 더해 수학적인 함수처럼 사용되며 부작용을 일으키지 않는 함수를 의미한다. 

* 자바 8에서는 함수를 새로운 값의 형식으로 추가했다. 이는 이후 `Stream`에서 설명할 멀티코어에서 병렬 프로그래밍을 활용할 수 있는 스트림과 연계될 수 있도록 함수를 만들었기 때문이다. 먼저 함수를 값처럼 취급한다고 했는데 이 특징이 어떤 장점을 제공하는지 살펴보자. 

* 자바 프로그램에서 조작할 수 있는 값
  - 42: `int`
  - 3.14: `double`
  - 객체(엄밀히 따지면 객체의 reference): `instance`. `new` 또는 팩토리 메서드 또는 라이브러리 함수를 이용해 객체의 값을 얻을 수 있음
    + "abc"
    + new Integer(1111)
    + new HashMap<Integer, String>(100)
  - Array

* 함수는 왜 필요할까? 프로그래밍 언어의 핵심은 값을 바꾸는 것이다. 역사적으로 그리고 전통적으로 프로그래밍 언어에서는 이 값을 일급`first-class` 값(또는 시민`citizens`)이라고 부른다. 자바 프로그래밍 언어의 다양한 구조체(메서드, 클래스 같은)가 값의 구조를 표현하는 데 도움이 될 수 있다. 하지만 프로그램을 실행하는 동안 이러한 모든 구조체를 자유롭게 전달할 수는 없다. 이렇게 전달할 수 없는 구조체는 이급 시민이다. 위에서 언급한 값은 모두 일급 자바 시민이지만 메서드, 클래스 등은 이급 자바 심니에 해당한다. 메서드와 클래스는 그 자체로 값이 될 수 없다. 

* 따라서 자바 8 설계자들은 이급 시민을 일급 시민으로 바꿀 수 있는 기능을 추가했다. 

#### Method, Labmbda를 일급 시민으로 
* `Method Reference`
  - 기존에 객체 참조`object reference`를 이용해 객체를 이리저리 주고받았던 것처럼 자바 8에서는 메서듳 참조를 만들어 전달할 수 있게 되었다.
  - 필터링을 하기 위해 아래와 같은 방식으로 `isHidden`의 결과를 `File.listFiles` 메서드로 전달할 수 있다. 
    ```java
    File[] hiddenFiles = new File(".").listFiles(new FileFilter() {
        public boolean accept(File file) {
            return file.isHidden();
        }
    })
    ```

  - 자바 8에서는 아래와 같이 코드를 구현할 수 있다. 
    ```java
    File[] hiddenFiles = new File(".").listFiles(File::isHidden);
    ```

* `Lambda`: 익명 함수 
  - 자바 8에서는 (기명`named`) 메서드를 일긊값으로 취급할 뿐 아니라 람다(또는 익명 함수`anonymous function`)를 포함하여 함수도 값으로 취급할 수 있다. 람다 문법 형식으로 구현된 프로그램을 함수형 프로그래밍, 즉 '함수를 일급값으로 넘겨주는 프로그램을 구현한다'라고 한다. 


### Stream
* 거의 모든 자바 애플리케이션은 컬렉션을 만들고 활용한다. 하지만 컬렉션으로 모든 문제가 해결되는 것은 아니다. 우선은 스트림 API를 이용하면 컬렉션 API와는 상당히 다른 방식으로 데이터를 처리할 수 있다. 컬렉션에서는 반복 과정을 직접 처리해야 한다. 즉, `for-each` 루프를 이용해서 각 요소를 반복하면서 작업을 수행했다. 이런 방식의 반복을 외부 반복`external iteration`이라고 한다. 반면 스트림 API를 이용하면 루프를 신경 쓸 필요가 없다. 스트림 API에서는 라이브러리 내부에서 모든 데이터가 처리된다. 이와 같은 반복을 내부 반복`internal iteration`DLFKRH GKSEK. 

* 자바 8은 스트림 API로 '컬렉션을 처리하면서 발생하는 모호함과 반복적인 코드 문제' 그리고 '멀티코어 활용 어려움'이라는 두 가지 문제를 모두 해결했다. 기존의 컬렉션에서는 데이터를 처리할 때 반복되는 패턴이 너무 많았다. 따라서 라이브러리에서 이러한 반복되는 패턴을 제공한다면 좋을 것이라는 아이디어가 변화의 동기가 되었다. 즉, 자주 반복되는 패턴으로 주어진 조건에 따라 데이터를 `filtering`하거나, `extracting`하거나, `grouping`하는 등의 기능이 있다. 또한 이러한 동작들을 쉽게 병렬화할 수 있다는 점도 변화의 동기가 되었다. 예를 들어 두 CPU를 가진 환경에서 리스트를 필터링할 때 한 CPU는 리스트의 앞부분을 처리하고, 다른 CPU는 리스트의 뒷부분을 처리하도록 요청할 수 있다. 이 과정을 포킹 단계`forking step`라고 한다. 그리고 각각의 CPU는 자신이 맡은 절반의 리스트를 처리한다. 마지막으로 하나의 CPU가 두 결과를 정리한다. 


#### 자바의 병렬성과 공유되지 않은 가변 상태 
* 라이브러리에서 분할 처리 
  - 큰 스트림을 병렬로 처리할 수 있도록 작은 스트림으로 분할
* `filter` 같은 라이브러리 메서드로 전달된 메서드가 상호작용을 하지 않는다면 가변 공유 객체를 통해 병렬성을 얻게 됨 
* 함수형 프로그래밍에서 함수형이란 '함수를 일급값으로 사용한다'는 의미도 있지만, 부가적으로 '프로그램이 실행되는 동안 컴포넌트 간에 상호작용이 일어나지 않는다'라는 의미도 포함


### Default method and java module
* 요즘은 외부에서 만들어진 컴포넌트를 이용해 시스템을 구축하는 경향이 있다. 

* 자바 9의 모듈 시스템은 모듈을 정의하는 문법을 제공하므로 이를 이용해 피키지 모음을 포함하는 모듈을 정의할 수 있다. 모듈 덕분에 JAR 같은 컴포넌트에 구조를 적용할 수 있으며 문서화와 모듈 확인 작업이 용이해졌다. 

* 자바 8에서는 인터페이스를 쉽게 바꿀 수 있도록 디폴트 메서드를 지원한다. 디폴트 메서드는 특정 프로그램을 구현하는 데 도움을 주는 기능이 아니라 미래에 프로그램이 쉽게 변화할 수 있는 환경을 제공하는 기능이다. 

* Java는 다중구현을 지원한다. 그러므로 여러 인터페이스에 다중 디폴트 메서드가 존재할 수 있다는 것은 결국 다중 상속이 허용된다는 의미일까? 엄밀히 다중 상속은 아니지만 어느 정도는 '그렇다'고 말할 수 있다. 추후에 C++에서 악명 높은 다이아몬드 상속 문제`diamond inheritance problems`를 피할 수 있는 방법을 설명한다. 


## 정리
* 자바 8: 메서드 전달, 람다 등의 기능 추가 
* 자바 9: 대규모 컴포넌트를 정의하고 사용하는 기능 추가, 이를 이용해 모듈을 사용하거나 리액티브 프로그래밍 툴킷을 임포트해 시스템을 구성할 수 있게 됨 
* 자바 10: 이전 버전에 비해 지역 변수 추론이라는 사소한 기능 변화 
* 자바 11: 더 풍부해진 람다 표현식 인수 문법