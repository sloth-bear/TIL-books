# Today I Learned

| 구분 | 내용                        |
| ---- | --------------------------|
| DATE | 2024.01.26                |
| PART | 52. 다중정의는 신중히 사용하라 |

# 8장 Method
* 이번 장에서는 메서드를 설계할 때 주의할 점들을 살펴본다.
* 구체적으로는 매개변수와 반환값을 어떻게 처리해야 하는지, 메서드 시그니처는 어떻게 설계해야 하는지, 문서화는 어떻게 해야 하는지를 다룬다. 
* 상당 부분은 메서드뿐 아니라 생성자에도 적용된다. 
* 사용성, 견고성, 유연성에 집중할 것이다.

## Item52. 다중정의는 신중히 사용하라

### Overloading method vs overriding method
* 다중정의한 메서드는 정적으로 선택되고, 재정의한 메서드는 동적으로 선택된다. 
* e.g. `Collection, Set, List` 타입 각각으로 다중정의한 메서드에 대해 상위타입인 `Collection`을 기반으로 실행해보면 모두 `Collection` 타입으로 실행됨을 확인할 수 있다. 왜? 다중정의한 메서드는 컴파일 타임에 선택되기 때문이다. 런타임에야 타입이 달라지겠지만, 컴파일 타임에는 상위타입인 `Collection`을 기반으로 실행했기 때문이다. 
* 때문에 다중정의한 메서드는 프로그래머가 기대한 대로 동작하지 않을 수 있다. **<u>이렇게 헷갈릴 수 있는 코드는 작성하지 않는 것이 좋다.</u>** 특히나 public API라면 더욱 신경 써야 한다.
* 정확히 어떻게 사용했을 때 다중정의가 혼란을 주는지에 대해서는 논란의 여지가 있다. 안전하고 보수적으로 가려면 매개변수 수가 같은 다중정의는 만들지 말자. 가변인수(varargs)를 사용하는 메서드라면 다중정의를 아예 하지 말아야 한다. e.g. `ObjectOutputStream`의  write*Type* 메서드


### Overloading
* **메서드를 다중정의 할 때, 서로 다른 함수형 인터페이스라도 같은 위치의 인수로 받아서는 안 된다.**
* 어떤 다중정의 메서드가 불리는지 몰라도 기능이 같다면 신경 쓸 것은 없다. 이렇게 하는 가장 일반적인 방법은 상대적으로 더 특수한 다중정의 메서드에서 덜 특수한(더 일반적인) 다중정의 메서드로 일을 넘겨버리는(forward) 것이다.

#### overloading이 혼란을 일으키는 예
* `List`의 `remove(int index)`와 `remove(Object o)`는 다중정의되어있다. java 5부터 도입된 오토박싱에 의해 기본 타입과 참조 타입이 서로 형변환 가능해지게 되었다. (근본적으로 다르지 않게 되었다.) 그렇다면 `List<Integer>`의 원소를 int로 지우면 어떤 결과가 나올까? -> 의도한 결과가 나오지 않을 수 있으므로, 정확하게 표현하는 것이 필요하다. e.g. `remove(Object)`를 사용하려면 `Integer.valueOf(i)`와 같은 식이다. 
* `Executors.newCachedThreadPoll().submit(System.out::println)`은 컴파일 에러가 난다. `Runnable`과 `Callable`을 받는 `submit` 메서드가 다중정의되어있기 때문이다. 
* `String` 클래스의 `valueOf(char[])`과 `valueOf(Object)`는 같은 객체를 건네더라도 전혀 다른 일을 한다. 혼란을 불러올 수 있는 잘못된 사례다. 


### Constructor overloading
* 생성자는 이름을 다르게 지을 수 없으니 두 번째 생성자부터는 무조건 다중정의가 된다. 하지만 정적 팩터리라는 대안을 활용할 수 있는 경우가 많다. 
* 여러 생성자가 같은 수의 매개변수를 받아야 하는 경우를 완전히 피해갈 순 없으니 안전 대책을 배우는 것이 도움이 된다. 


