# Today I Learned

| 구분 | 내용                     |
| ---- | -----------------------|
| DATE | 2024.01.09             |
| PART | 28. 배열보다는 리스트를 사용하라 |

# 5장 Generic
* 자바 5부터 지원된 generic - 지원 전에는 컬렉션에서 객체를 꺼낼 때마다 형변환을 해야 했다. 
* 제네릭 사용 시 컬렉션이 담을 수 있는 타입을 컴파일러에게 알려주게 된다: 컴파일 타임에서 형변환 오류를 차단하므로 더 안전하고 명확한 프로그램을 만들어준다. 
* 컬렉션이 아니더라도 관련 이점을 누릴 수 있다. 
* 이번 장에서는 제네릭의 이점을 최대로 살리고 단점을 최소화하는 방법을 이야기한다.

## Item28. 배열보다는 리스트를 사용하라

### 배열과 제네릭 타입의 차이 
#### 1. 공변
* 배열은 공변(convariant)이다. 
	* Sub가 Super의 하위 타입이라면 배열 Sub[]는 배열 Super[]의 하위 타입이 된다. 
* 제네릭은 불공변(invariant)이다.
	* 서로 다른 타입 `Type1, Type2`가 있을 때 `List<Type1>`은 `List<Type2>`의 하위 타입도 상위 타입도 아니다.

공변: 런타임 시에 알 수 있다.
```java
Object[] objectArray = new Long[1];
objectArray[0] = "타입이 달라 넣을 수 없다."; // ArrayStoreException 
```

불공변: 컴파일 시점에 알 수 있다. 
```java
List<Object> ol = new ArrayList<Long>();
ol.add("타입이 달라 넣을 수 없다.")
```

#### 2. 실체화 (reify)
* 배열: 런타임에도 자신이 담기로 한 원소의 타입을 인지하고 확인한다. 그래서 Long 배열에 String을 넣으려 하면 ArrayStoreException이 발생한다. 
* 제네릭: 타입 정보가 런타임에는 소거(erasure)된다. 원소 타입을 컴파일 타임에만 검사하여 런타임 시에는 알 수조차 없다. (소거는 제네릭이 지원되기 전의 레거시 코드와 제네릭 타입을 함께 사용할 수 있게 해주는 메커니즘이다. 자바 5가 제네릭으로 순조롭게 전환될 수 있도록 해주었다.)


### 배열과 제네릭은 두 가지 중요한 차이로 잘 어우러지지 못한다. 
* 위의 두 주요 차이로 인해 잘 어우러지지 못한다. 
* e.g. 배열은 제네릭 타입, 매개변수화 타입, 타입 매개변수로 사용할 수 없다. `new List<E>[], new List<String>[], new E[]` 식으로 작성하면 컴파일할 때 제네릭 배열 생성 오류를 일으킨다. 
* 이유는 타입 안전하지 않기 때문이다. 이를 허용한다면 컴파일러가 자동 생성한 형변환 코드에서 런타임에 `ClassCastExcpetion`이 발생할 수 있다. 런타임에 `ClassCastExcpetion`이 발생하는 일을 막아주겠다는 제네릭 타입 시스템의 취지에 어긋나는 것이다.

```java
List<String>[] stringLists = new List<String>[1]; // 1. 만약 컴파일이 된다면?
List<Integer> intList = List.of(42);
Object[] objects = stringLists;
objects[0] = intList;
String s = stringLists[0].get(0); // ClassCastException
```


### Generic의 특징
1. `E`, `List<E>`, `List<String>` 같은 타입을 실체화 불가 타입(non-reifiable type)이라고 한다. 실체화되지 않아서 런타임에는 컴파일타임보다 타입 정보를 적게 가지는 타입이다. 소거 메커니즘 때문에 매개변수화 타입 가운데 실체화될 수 있는 타입은 `List<?>` 같은 비한정적 와일드카드 타입 뿐이다. 배열을 비한정적 와일드카드 타입으로 만들 수는 있지만, 유용하게 쓰일 일은 거의 없다. 
2. 배열로 형번환 시 제네릭 배열 생성 오류/형변환 경고가 뜨는 경우 대부분은 `E[]` 대신 `List<E>`를 사용하면 해결된다. 코드가 조금 복잡해지고 성능이 살짝 나빠질 수 있지만 그 대신 타입 안전성과 상호운용성이 좋아진다. 