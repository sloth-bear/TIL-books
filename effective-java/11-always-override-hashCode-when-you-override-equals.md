# Today I Learned

| 구분 | 내용                            |
| ---- | ------------------------------|
| DATE | 2024.01.05                    |
| PART | 11. equals를 재정의하려거든 hashCode도 재정의하라 |

# 4장 Methods common to All Objects (모든 객체의 공통 메서드)
* `Object`: 객체를 만들 수 있는 구체 클래스지만, 기본적으로는 상속해서 사용하도록 설계됨 
* `final`이 아닌 메서드(`equals, hashCode, toString, clnoe, finalize`)는 모두 overriding을 염두에 두고 설계된 것이라 재정의 시 지켜야 하는 일반 규약이 명확히 정의되어 있음. 
* 그래서 `Object`를 상속하는 클래스, 즉 모든 클래스는 이 메서드들을 일반 규약에 맞게 재정의해야 함 -> 만약 메서드를 잘못 구현하면 대상 클래스가 이 규약을 준수한다고 가정하는 클래스(`HashMap`과 `HashSet` 등)를 오작동하게 만들 수 있다. 
* ***`final`이 아닌 `Object` 메서드들을 언제 어떻게 재정의해야 하는가에 초점***

## Item11. equals를 재정의하려거든 hashCode도 재정의하라

`equals`를 재정의한 클래스 모두에서 `hashCode`도 재정의해야 한다. 그렇지 않으면 `hashCode` 일반 규약을 어기게 되어 해당 클래스의 인스턴스를 HashMap이나 HashSet 같은 컬렉션의 원소로 사용할 때 문제를 일으킬 것이다. 


### `Object` spec
* equals 비교에 사용되는 정보가 변경되지 않았다면, 애플리케이션이 실행되는 동안 그 객체의 `hashCode` 메서드는 몇 번을 호출해도 일관되게 항상 같은 값을 반환해야 한다. 단, 애플리케이션을 다시 실행한다면 이 값이 달라져도 상관없다.
* `equals`가 두 객체를 같다고 판단했다면, 두 객체의 `hashCode`는 같은 값을 반환해야 한다. 
* `equals`가 두 객체를 다르다고 판단했더라도, 두 객체의 `hashCode`가 서로 다른 값을 반환할 필요는 없다. 단, 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 좋아진다.


#### `hashCode` 재정의를 잘못했다면?
위에 작성된 `Object` spec의 두 번째 조항을 어기게 된다. 논리적으로 같은 객체는 같은 해시코드를 반환해야 한다. 

```
Map m = new HashMap<>(); 
m.put(new PhoneNumber(707, 867, 5309), "제니");
```
만약 논리적 동치인 두 객체가 서로 다른 해시코드를 반환하여 두 번째 규약을 지키지 못한다면, 예를 들어 `HashMap`에서 그 객체를 통해 값을 꺼내지 못한다. `get` 메서드가 엉뚱한 해시 버킷에 가서 객체를 찾으려 할 것이다. 같은 버킷이라 하더라도 다른 엔트리끼리는 동치성 비교 시도조차 하지 않도록 최적화되어있으므로 `null`을 반환한다. 


### 올바른 `hashCode` 메서드는 어떤 모습이어야 할까?
#### 안 좋은 예
```java
@Override
public int hashCode() {
	return 42;
}
```
* 동치인 모든 객체에서 같은 해시코드를 반환하니 적법하다.
* 그러나 모든 객체에게 똑같은 값만 내어주므로 모든 객체가 해시테이블의 버킷 하나에 담겨 마치 연결 리스트(linked list)처럼 동작한다. -> 평균 수행 시간이 O(1)인 해시테이블이 O(n)으로 느려져 객체가 많아지면 쓸 수 없게 된다.

#### 올바른 예
* 서로 다른 인스턴스에 다른 해시코드를 반환한다. (3번쨰 규약이 요구하는 속성)
* 이상적인 해시 함수는 주어진 (서로 다른) 인스턴스들을 32비트 정수 범위에 균일하게 분배해야 한다. 완벽히 실현하긴 어렵겠으나 비슷하게 만들기는 그다지 어렵지 않다. 

##### 올바른 예 작성 요령
1. `int` 변수 `result` 선언 후 값 `c`로 초기화한다. 이때 `c`는 해당 객체의 첫 번째 핵심 필드를 단계 2, a 방식으로 계산한 해시코드다. (여기서 핵심 필드란 `equals` 비교에 사용되는 필드를 말한다. Item 10 참조)
2. 해당 객체의 나머지 핵심 필드 `f` 각각에 대해 다음 작업을 수행한다. 
	1. 해당 필드의 해시코드 `c`를 계산한다.
		1. 기본 타입 필드: `Type.hashCode(f)` 수행 - `Type`: 해당 기본 타입의 박싱 클래스
		2. 참조 타입 필드면서 이 클래스의 `equals` 메서드가 이 필드의 `equals` 를 재귀적으로 호출해 비교한다면, 이 필드의 `hashCode`를 재귀적으로 호출한다. 계산이 더 복잡해질 것 같으면, 이 필드의 표준형(canonical representation)을 만들어 그 표준형의 `hashCode`를 호출한다. 필드의 값이 `null`이면 0을 사용한다. (다른 상수도 괜찮으나 전통적으로 0을 사용)
		3. 필드가 배열: 핵심 원소 각각을 별도 필드처럼 다룬다. 이상의 규칙을 재귀적으로 적용해 각 핵심 원소의 해시코드를 계산한 다음, 단계 2.b 방식으로 갱신한다. 배열에 핵심 원소가 하나도 없다면 단순히 상수(0을 추천)를 사용한다. 모든 원소가 핵심 원소라면 `Arrays.hashCode`를 사용한다.
	2. 단계 2.a에서 계산한 해시코드 `c`로 `result`를 갱신한다. `result = 31 * result + c;`
3. result를 반환한다. 

#### 주의사항 
1. `hashCode` 구현 후 이 메서드가 동치인 인스턴스에 대해 같은 해시코드를 반환하는지 확인하고 단위 테스트를 작성해보자. 
2. 파생 필드는 해시코드 계산에서 제외해도 된다. 즉, 다른 필드로부터 계산해낼 수 있는 필드는 모두 무시해도 된다.
3. `equals` 비교에 사용되지 않은 필드는 ***반드시*** 제외해야 한다. 그렇지 않으면 두 번쨰 규약을 어기게 될 수 있다. 
4. 31을 곱하면, 이 곱셈을 시프트 연산과 뺄셈으로 대체해 최적화할 수 있다. (요즘 VM들은 이런 최적화를 자동으로 해준다.)
	1. 곱셈 없이 구현하면 해시 효과가 떨어질 수 있다. e.g. `String`: 곱셈 없이 구현 시에 모든 아나그램의 해시코드가 같아진다.
	```java
	@Override
	public int hashCode() {
		int result = Short.hashCode(areaCode);
		result = 31 * result + Short.hashCode(prefix);
		result = 31 * result + Short.hashCode(lineNum);
		return result;
	}
	```
5. 해시 충돌이 더욱 적은 방법을 써야 한다면 구아바의 `com.google.common.hash.Hashing`을 참고하자. 
6. `Objects`의 `hash`: 요령대로 구현한 코드와 비슷한 수준의 `hashCode` 함수를 단 한 줄로 작성 가능하지만, 속도가 느리다. 박싱과 언박싱도 거칠 수 있으므로 성능에 민감하지 않은 상황에서만 사용하자. 
	```java
	@Override 
	public int hashCode() {
		return Objects.hash(lineNum, prefix, areaCode);
	}
	```
7. 클래스가 불변이고 해시코드를 계산하는 비용이 크다면, 매번 새로 계산하기보다는 캐싱하는 방식을 고려해야 한다. 이 타입의 객체가 주로 해시의 키로 사용될 것 같다면 인스턴스가 만들어질 때 해시코드를 계산해둬야 한다. 해시의 키로 사용되지 않는 경우라면 hashCode가 처음 불릴 때 사용하는 지연 초기화 전략도 있다. (이 경우 thread 안전하게 만들도록 신경써야 한다. Item 83)
	```java
	private int hashCode;

	@Override
	public int hashCode() {
		int result = hashCode;
		if (result == 0) {
			result = Short.hashCode(areaCode);
			result = 31 * result + Short.hashCode(prefix);
			result = 31 * result + Short.hashCode(lineNum);
			hashCode = result;
		}
		return result;
	}
	```
	8. 성능 향상 때문이라도 해시코드 계산 시 핵심 필드를 생략해서는 안 된다. 해시 품질이 나빠져 해시테이블의 성능을 심각하게 떨어뜨릴 수 있다. 
	9. `hashCode`가 반환하는 값의 생성 규칙을 API 사용자에게 자세히 공표하지 말자. 그래야 client가 이 값에 의지하지 않게 되고 추후에 계산 방식을 바꿀 수도 있다. (java library의 많은 클래스가 정확한 값을 알려주는데, 바람직하지 않은 실수다.)



