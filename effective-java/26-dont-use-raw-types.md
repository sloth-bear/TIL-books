# Today I Learned

| 구분 | 내용                     |
| ---- | -----------------------|
| DATE | 2024.01.08             |
| PART | 26. Raw 타입은 사용하지 말라 |

# 5장 Generic
* 자바 5부터 지원된 generic - 지원 전에는 컬렉션에서 객체를 꺼낼 때마다 형변환을 해야 했다. 
* 제네릭 사용 시 컬렉션이 담을 수 있는 타입을 컴파일러에게 알려주게 된다: 컴파일 타임에서 형변환 오류를 차단하므로 더 안전하고 명확한 프로그램을 만들어준다. 
* 컬렉션이 아니더라도 관련 이점을 누릴 수 있다. 
* 이번 장에서는 제네릭의 이점을 최대로 살리고 단점을 최소화하는 방법을 이야기한다.

## Item26. Raw 타입은 사용하지 말라

### Generic class / Generic Interface
* 제네릭 클래스 / 제네릭 인터페이스: 클래스와 인터페이스 선언에 타입 매개변수(type parameter)가 쓰이는 경우 
* 제네릭 클래스와 제네릭 인터페이스를 통 틀어 제네릭 타입(generic type)이라고 한다.
* e.g. `List<E>`


#### parameterized type (매개변수화 타입)
* 각각의 제네릭 타입은 일련의 매개변수화 타입을 정의한다.
* 먼저 클래스(혹은 인터페이스) 이름이 나오고, 이어서 꺽쇠괄호 안에 실제 타입 매개변수들을 나열한다. 
* e.g. `List<String>`: 원소의 타입이 `String`인 리스트를 뜻하는 매개변수화 타입, 여기서 `String`이 정규(formal) 타입 매개변수 E에 해당하는 실제(actual) 타입 매개변수

#### raw type
* raw type: generic type에서 타입 매개변수를 전혀 사용하지 않을 때 
* 제네릭 타입을 하나 정의하면 그에 딸린 Raw type도 함께 정의된다.
* raw type은 타입 선언에서 제네릭 타입 정보가 전부 지워진 것처럼 동작한다.  - 제네릭이 안겨주는 안전성과 표현력을 모두 잃게 된다.
* e.g. `List<E>`의 raw type: `List`
* 이 경우 의도한 타입 외의 타입을 넣더라도 아무 오류 없이 컴파일되고 실행된다(컴파일러가 모호한 경고 메세지를 보여줄 것 - unchecked call) -> 꺼내기 전까지는 알 수가 없다. 
  * 오류는 가능한 한 발생 즉시, 이상적으로는 컴파일할 때 발견하는 것이 좋다.
* raw type 지원 이유: 제네릭을 받아들이기까지 거의 10년이 걸리면서 제네릭 없이 짠 코드가 너무 많아 새로운 코드와도 맞물려 돌아가게 해야만 했다 -> 제네릭이 도래하기 전 코드와 호환되도록 하기 위한 궁여지책
* `List<Object>`처럼 임의 객체를 허용하는 매개변수화 타입은 괜찮다. raw type과 달리 모든 타입을 허용한다는 의사를 컴파일러에 명확히 전달한 것이다. 또한 `List<Object>`에는 `List<String>` 같은 타입을 넘길 수 없다. 제네릭의 하위 타입 규칙 때문이다. 


#### unbounded wildcard type (비한정적 와일드카드 타입)
* 원소의 타입이 무엇인지 신경 쓰고 싶지 않다면 "?"를 사용하자.
* raw type과 달리 안전하다. raw type 컬렉션에는 아무 원소나 넣을 수 있으니 타입 불변식을 훼손하기 쉽다. 그러나 `Collection<?>`에는 (`null` 외에는) 아무 원소도 넣을 수 없다.
* 이러한 제약을 받아들일 수 없으므로 제네릭 메서드(Item 30) 혹은 한정적 와일드카드 타입(Item 31)을 사용하면 된다. 


### 그 외 규칙
1. `class` literal에는 raw 타입을 써야 한다. 
    e.g. `List.class`, `String[].class`는 허용하나 `List<String>.class`와 `List<?>.class`는 허용하지 않는다.
2. `instanceof` 연산자는 비한정적 와일드카드 타입 이외의 매개변수와 타입에는 적용할 수 없다. 즉, raw type이든 비한정적 와일드카드 타입이든 `instanceof` 메서드는 완전히 똑같이 동작한다. 
    ```java
    if (o instanceof Set) {
      Set<?> s = (Set<?>) o; // checked cast
    }
    ```

