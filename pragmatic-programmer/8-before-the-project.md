# Today I Learned
| 구분  | 내용                   |
|------|-----------------------|
| DATE | 2022.05.29            |
| PART | 8. Before the project |


## 1. 기억하고 싶은 내용 
여러분 그리고 여러분의 팀은 프로젝트를 시작할 때 요구사항을 파악해야 한다. 단순히 할 일을 전달받거나, 사용자의 이야기를 듣는 것만으로는 부족하다. 불가능한 프로젝트와 맞닥ㄷ트렸다면 우리의 비밀 무기인 <함께 일하기>를 꺼내야 한다. <함께 일하기>는 두꺼운 요구 사항 문서를 공유하거나, 참조자가 무한히 늘어나는 이메일을 뿌리거나, 끝없는 회의를 견디는 것이 아니다. 우리가 생각하는 함께 일하기는 코딩하는 동안 문제를 함께 푸는 것이다. 

애자일 선언`agile Manifesto`은 "공정`process`과 도구보다 개인과 상호 작용"으로 시작한다. 하지만 역설적이게도 거의 모든 "애자일" 프로젝트가 어떤 공정과 도구를 사용할지에 대한 논의로 시작한다. 하지만 아무리 세심하게 계획하거나, 최고의 "모범 사례"를 따라 하더라도, 생각하기를 대신할 수는 없다. 여러분에게 필요한 것은 특정한 공정이나 도구가 아니다. 

프로젝트가 닻을 올리기 전에 이런 중요한 문제들이 잘 정리되어야 '분석 마비증`analysis paralysis`'을 모면할 수 있다. 프로젝트를 정말로 시작하고, 성공적으로 마칠 수 있다. 


### 1-1. 요구 사항의 구렁텅이 
* `완성이라는 것은 더 이상 더할 것이 없을 때가 아니라, 더 이상 뺄 것이 없을 때 달성되는 것이다.`

* 요구 사항이 땅 위에 놓여 있는 경우는 드물다. 보통은 가정과 오해, 정치`politics`의 지층 속 깊숙이 묻혀 있다. 심지어 아예 존재하지 않을 때도 있다. `자신이 뭘 원하는지 정확히 아는 사람은 아무도 없다.`

* 소프트웨어 산업 초창기, 시간당 비용 기준으로 컴퓨터가 컴퓨터를 다루는 사람보다 훨씬 비싸던 시절이 있었다. 우리의 목표는 단번에 제대로 동작하게 만들어서 비용을 절약하는 것이었다. 그 노력의 일환으로 기계가 해야 할 일을 정확하게 기술하려고 애썼다. 요구 사항의 명세, 설계 문서, 순서도, 의사 코드, 코드 구현, 컴퓨터에 입력하기 전 사람이 한 번 더 코드 검사하기... 이렇게 하려면 돈이 많이 든다. 초기의 컴퓨터는 기능이 충분치 않아서 컴퓨터로 해결할 수 있는 문제의 폭도 제한적이었다. 그래서 전체 문제를 먼저 다 이해한 후에 작업을 시작하는 것이 실제로 가능했다. 하지만 진짜 세상은 다르다. 진짜 세상은 엉망이고 갈등이 넘쳐나며 알 수 없는 점도 많다. 무엇을 다루든 정확한 명세란 것은 거의 불가능하다고 볼 수 있다. 그래서 우리 프로그래머들이 등장한다. `프로그래머는 사람들이 자신이 원하는 바를 깨닫도록 돕는다.`

* 신입 개발자들이 자주 범하는 실수는 이런 요청 사항을 받았을 때 바로 해결책을 구현해 버리는 것이다. 우리의 경험상 최초의 요청 사항은 궁극적인 요구 사항이 아니다. 의뢰인은 인식하지 못할 수도 있지만, 의뢰인의 요청 사항은 사실 함께 탐험을 떠나자는 초대장이다. 간단한 예를 들어 보자. 여러분은 종이책과 전자책을 파는 온라인 서점에서 일한다. 새로운 요구 사항을 받았다. `5만원 이상인 모든 주문은 배송비가 무료입니다.` 잠시 멈춰서 이런 요구사항을 받았다고 상상해 보라. 아마 이런 의문점들이 떠올랐을 것이다. 
  * 어떤 종류의 배송이 무료인가? 당일 배송? 일반 배송? 
  * 5만 원이 모두 종이책이어야 하나? 아니면 전자책을 포함해도 되나? 
  * 나중에 5만 원 기준이 또 바뀔까? 
  * 5만 원에 현재 고객이 선택한 배송 방법의 배송비도 포함인가? 
  이렇게 시작된다. 여러분의 역할은 의뢰인의 말을 해석해서 그로 인한 영향을 다시 알려주는 것이다. 여러분은 순간적으로 판단을 내리며 해결책을 만드는 데 참여한다. 이 해결책은 여러분이나 의뢰인이 혼자서 만들어 내는 것보다 아마 더 좋을 것이다. `요구사항은 피드백을 반복하며 알게 된다.`

* 말로 표현하기 쉽지 않을 때도 많다. 읷국하지 않은 분야여서 구체적으로 피드백을 주기 어려울 수도 있다. 그럴 때 모형`mockup`이나 프로토타입을 만들어서 의뢰인이 직접 다루어 볼 수 있도록 한다. 의뢰인과 대화하는 도중에도 계속 바꿀 수 있다면 이상적이다. 사실 프로젝트 막바지가 되면 의뢰인의 수가 늘어난다. QA, 운영팀, 마케팅, 고객사의 테스트 조직 등... 그러니 실용주의 프로그래머는 프로젝트 전체를 요구 사항 수집 과정으로 보아야 한다. 

* 사업 정책인가? 요구 사항인가? 그 차이는 비교적 미묘하다. 하지만 이 차이가 개발자에게는 중대한 의미가 있다. 만약 요구 사항이 "인사팀에서만 직원 기록을 열람할 수 있다."는 식으로 되어 있다면, 개발자는 애플리케이션이 이 데이터에 접근할 때마다 인사팀인지 확인하는 코드를 작성할 것이다. 하지만 요구 사항이 "권한이 있는 사용자만이 직원 기록에 접근할 수 있다."는 식이라면 개발자는 아마도 일종의 접근 관리 시스템을 설계하고 구현할 것이다. 그러면 정책이 바뀔 때(실제로 바뀐다) 시스템의 메타데이터`Metadata`만 업데이트 하면 된다. 실제로 이런 식으로 요구 사항을 수집하면 자연스럽게 메타데이터를 지원하는 잘 분리된 시스템이 만들어질 것이다. 사실 여기엔 일반 원칙이 있다. `정책은 메타데이터다.`

* 우리는 최고의 요구 사항 문서, 아니 아마 유일한 요구 사항 문서는 작동하는 코드라고 믿는다. 그렇다고 의뢰인이 원하는 바를 여러분이 어떻게 이해했느닞 문서로 정리하지 않아도 된다는 뜻은 아니다. 그저 문서는 목표가 아니고, 의뢰인에게 승인해 달라고 들이밀 수 있는 것도 아니라는 뜻일 뿐이다. 문서는 구현 과정에서 안내 역할을 하는 이정표일 뿐이다. 의뢰인이 프로그래머를 고용하는 이유는 의뢰인은 고차원적이고 모호한 측면이 있는 문제를 풀고 싶어 하는 반면, 프로그래머는 세부 사항과 미묘한 차이 하나하나에 관심을 두기 때문이다. 요구 사항 문서는 개발자를 위해서 쓰는 것이다. 의뢰인이 보기에는 이해하기 어려운 부분도 많고, 온통 지루하기만 한 정보와 세부 요소들을 담고 있다. 두툼한 요구 사항 문서 뭉치는 필요 없다. 하지만 그래도 요구 사항을 적기는 해야 할 것이다. 

* 요구 사항 문서는 어떤 형식으로 적어야 할까? 우리는 진짜 인덱스카드 혹은 가상의 인덱스 카드에 들어갈 정도로 적는 방식을 선호한다. 이런 짧은 설명을 '사용자 스토리`user story`'라고도 부른다. 여기에는 애플리케이션의 작은 일부가 그 기능을 쓰는 사용자 관점에서 어떻게 작동해야 하는지를 적는다. 이렇게 적으면 요구 사항을 화이트보드에 붙일 수도 있고, 상태나 우선 순위를 표현하기 위해 이리저리 옮길 수도 있다. 인덱스카드 한 장에 애플리케이션 컴포넌트를 구현하는 데 필요한 정보를 모두 담지 못할 거라는 생각이 들 수도 있겠다. 맞다. 이 점이 중요하다. 요구 사항 설명을 짧게 제한하면 개발자들이 명확하지 않은 점을 물어보도록 유도할 수 있다. 코드를 작성하기 전이나 작성하는 도중에 일어나는 의뢰인과 개발자 간의 피드백 과정이 더 활발해지는 것이다. 

* 요구 사항을 기술할 때생기는 또 다른 심각한 문제는 지나치게 자세히 서술하는 것이다. 좋은 요구 사항은 추상적이다.
  * 사업에 필요한 사항 정확히 반영하는 가장 간단한 표현
  * 밑에 깔려 있는 의미론적 불변식을 잘 갈무리
  * 구체적인 작업 방식, 현재의 작업 방식은 정책으로 문서화 

* 많은 프로젝트가 범위`scope`의 증가 때문에 실패한다고 알려져 있다. 요구 사항이 슬금슬금 추가되는 것을 어떻게 막을 수 있을까? 해답은 다시 한 번 피드백이다. 반복 주기를 거치며 의뢰인과 정기적으로 피드백을 주고받는다면, "딱 한 기능만 더"라는 요청이 미치는 영향을 의뢰인이 직접 체험할 것이다. 화이트보드에 또 다른 스토리 카드를 올리겠지만, 그 카드를 구현할 시간을 확보하기 위해 다음 반복 주기로 미룰 카드 선택을 도와주게 될 것이다. 피드백은 서로 주고받는 것이다. 


### 1-2. 불가능한 퍼즐 풀기
* 프로젝트 진행 도중 때때로 정말 어려운 퍼즐을 붙잡고 씨름할 일이 생길 것이다. 도무지 이해가 안 되는 엔지니어링 문제일 수도 있고, 혹은 생각했던 것보다 훨씬 작성하기 어려운 코드일 수도 있다. 어쩌면 불가능해 보일지도 모르겠다. 하지만 보이는 것만큼 실제로도 정말 그렇게 어려울까? 이런 퍼즐을 푸는 비법은 상상 속이 아닌 실제 제약 조건을 알아내고, 그 속에서 해법을 찾는 것이다. 어떤 제약 조건은 절대적이지만, 다른 것들은 단순한 지레짐작에 불과하다. 절대적 제약 조건은 그것이 아무리 불쾌하거나 어리석어 보여도 꼭 따라야 한다. 

* 제약을 범주별로 나누고 우선순위를 매겨라. 가장 구속이 심한 제약부터 파악해 내고 나머지 제약을 그 안에서 맞춰 보아야 한다. 

* 어떤 때는 문제가 생각보다 훨씬 어려워 보이기도 한다. 잠깐 다른 일을 하라. `간단히 표현하면 딴짓을 한 사람이 의식적으로 노력한 사람보다 복잡한 문제 해결 과제를 더 잘 해냈다.`

* 고무 오리를 사용하라. 
  * 왜 이 문제를 풀고 있는가?
  * 문제를 풀어서 얻는 것이 무엇인가?
  * 풀려고 하는 문제가 특수한 경우에 해당하는가? 특수한 경우를 없앨 수는 없나?
  * 관련된 문제 중에 여러분이 풀 수 있는 더 간단한 문제는 없나? 


### 1-3. 함께 일하기 
* 불가능한 프로젝트가 있었다. 말도 안 되는 마감 기한의 불가능한 프로젝트. 이 프로젝트의 엄청난 성공은 오직 한 가지 덕분이었다. 기존 시스템을 수년간 관리한 전문가가 늘 자신의 사무실에 앉아 있었고, 우리 개발실 바로 건너편에 있었다. 덕분에 끊임없이 질문을 던지고, 설명을 듣고, 결정을 부탁하고, 시연을 보여 줄 수 있었다. 이 책 전반에 걸쳐 우리는 사용자와 밀접하게 함께 일하라고 권했다. 사용자는 여러분 팀의 일원이다. 이 프로젝트에서 우리는 요즘이라면 '페어 프로그래밍`pair programming`'이나, '몹 프로그래밍`mob programming`'이라고 부를 방식을 사용했다. 한 사람이 코드를 입력하는 동안 한 명 혹은 여러 명의 팀 종료가 조언하고 고민하며 문제를 함께 푸는 것이다. 이 방식은 함께 일하는 아주 강력한 방법이다. 끝없는 회의, 제안서, 법률 문서스러운 뭉서 뭉치보다 훨씬 낫다. 이것이 우리가 말하는 "함께 일하기"다. 실제로 코딩을 하는 와중에 질문을 하고 토론을 하는 것이다. 

#### Pair programming
* 익스트림 프로그래밍`eXtreme Programming, XP`의 실천 방법 중 하나였지만 XP와는 별개로도 유명해졌다. 짝 프로그래밍에서 개발자 한 명은 키보드를 조작하지만 다른 한 명은 하지 않는다. 키보드 담당은 필요에 따라 바꿀 수 있고, 둘이 함께 문제를 푼다. 입력을 담당한 개발자는 문법이나 코딩 스타일 같은 낮은 수준의 세부 사항에 집중해야만 한다. 반면에 다른 개발자는 문제를 더 높은 수준에서 넓은 범위를 보며 고민할 수 있다. 두 번째 사람의 존재로 인해 생기는 사회적인 압력은 변수 이름을 foo로 짓는 것 같은 나쁜 습관이나 약점으로부터 우리를 지켜준다. 

#### Mob programming
* 몹 프로그래밍은 셋 이상의 사람이 참여하는 짝 프로그래밍의 확장판이다. 몹 프로그래밍 지지자들은 몹 프로그래밍이 어려운 문제를 해결하는 데 아주 좋다고들 한다. 몹에는 사용자나 프로젝트 후원자, 테스터처럼 일반적으로 개발팀의 일부로 여겨지지 않는 사람도 쉽게 끌어들일 수 있다. 실시간 코딩을 곁들인 밀접한 협업이라고 생각해도 될 것이다. 

* 현재 늘 혼자서 프로그래밍을 하고 있다면 짝 프로그래밍을 시도해 봐도 좋을 것이다. 처음에는 어색할 테니 한 번에 두어 시간씩 최소 2주만 해 보라. 짝 프로그래밍이나 몹 프로그래밍을 이미 하고 있다면 누구와 함께 하는가? 개발자끼리만 하는가? 아니면 사용자나 테스터, 후원자 등 더 넓은 범위의 팀원과도 하는가? 이렇게 함께 일하는 동안 기술적인 면 외에 인간적인 측면도 신경 써야 한다. 
  * 코드를 짜는 거지 자아를 쌓는 게 아니다. 누가 가장 똑똑한지 겨루는 것이 아니다. 우리 모두는 각자 뛰어난 부분이나 장단점이 있다. 
  * 소규모로 시작하라. 네다섯 명과 몹을 만들어 보거나, 짝 프로그래밍을 짧게 몇 번 해보는 것을 시작하라. 
  * 코드만 비판하고 사람을 비판하지 말라. "넌 틀렸어."보다는 "이 부분을 한 번 볼까요?"가 훨씬 듣기 좋다. 
  * 다른 사람의 관점을 듣고 이해하려고 노력하라. 다른 것은 틀린 것이 아니다. 
  * 자주 회고를 하라. 그래서 다음번에 시도하거나 개선할 점을 찾아라. 

* 너무 무턱대고 접근하지는 말라. 각각의 개발 방식마다 규칙과 참고 사항, 지침들이 있다. 예를 들어 몹 프로그래밍을 할 때는 키보드를 입력하는 사람을 5~10분마다 바꿔 주어야 한다. 교과서와 사례 보고서를 모두 찾아보고 연구를 좀 하라. 장점과 걱정되는 점에 대한 감을 잡아라. `코드에 혼자 들어가지 말라.`


### 1-4. [애자일](https://agilemanifesto.org/iso/ko/manifesto.html)의 핵심 
* 애자일 소프트웨어 개발 선언이 탄생한 지 거의 20년이 흘렀다. 우리는 정말 많은 개발자들이 성공적으로 애자일의 가치를 적용하는 것을 보았다. 하지만 우리는 애자일의 다른 측면도 보았다. 팀이나 회사들이 기성품 해결책을 찾아 헤매는 모습을 보았다. 상자에 담겨 포장된 애자일 말이다. 이들이 원하는 것을 팔겠다고 신이 난 컨설턴트와 회사도 많이 보았다. 우리는 많은 사람들이 진정한 애자일의 의미를 잊어버렸다고 느낀다. 이제는 다들 기본으로 돌아와야 한다. 애자일 선언에서 언급한 가치를 기억하라. 
  * 공정과 도구보다 개인과 상호작용`Individuals and interactions over processes and tools`
  * 포괄적인 문서보다 작동하는 소프트웨어`Working software over comprehensive documentation`
  * 계약 협상보다 고객과의 협력`Customer collaboration over contract negotiation`
  * 계획을 따르기보다 변화에 대응하기`Responding to change over following a plan`

* 애자일 프로세스라는 것은 있을 수 없다. "이걸 하세요. 그러면 애자일인 겁니다."라고 한다면 이건 틀린 말이다. 정의상 그렇다.

* 물리적인 세계에서든 소프트웨어 개발에서든 애자일, 즉 기민함이란 것은 변화에 대응하는 것, 일을 시작한 이후 맞부딪히는 미지의 것에 대응하는 것의 전부이기 때문이다. 소프트웨어를 개발할 때 따라야 할 단 한가지 계획이란 없다. 이 가치들은 무엇을 하라고 알려 주지는 않는다. 대신 여러분이 할 일을 결정할 때 무엇을 추구해야 할지를 알려 준다. 그 결정은 언제나 상황에 따라 다르다. 여러분이 어떤 사람인지, 팀은 어떤 특징이 있는지, 애플리케이션이나 도구, 회사, 고객, 바깥세상은 어떤지에 따라 다르다. 엄청나게 많은 요인이 있고, 그 중 몇 가지는 중요하지만 몇 가지는 별 영향이 없다. 이렇게 불확실한 환경이라면 고정된 채 바뀌지 않는 계획은 살아남을 수 없다. 

* 우리가 제안하는 애자일하게 일하는 방법은 다음과 같다. 
  1. 여러분이 어디에 있는지 알아내라. 
  2. 도달하고 싶은 곳을 향하여 의미 있는 발걸음을 가능한 한 작게 옮겨라. 
  3. 어디에 도착했는지 평가하고, 망가트린 거이 있으면 고쳐라.

* 좋은 설계의 척도는 설계의 결과물을 얼마나 바꾸기 쉬운지라고 주장했다. 좋은 설계는 나쁜 설계보다 바꾸기 쉬운 결과물을 만든다. 바꾸기 쉽다면 모든 층위에서 아무런 주저 없이 문제를 바로잡을 수 있을 것이다. 


## 2. 소감
애자일 소프트웨어 개발 선언을 보고 나서 여러 기분이 교차했다. 내가 지금까지 참여했던 프로젝트들은 대부분 기획서가 구체적이지 않거나, 이해하기 어렵거나, 존재하지 않을 때도 있었다. 그리고 작업할 떄는 주로 큰 줄기에 이상이 없다면 일단 시작하면서 피드백을 주고 받기도 했고, 이 과정에서 잘못된 경우가 있어 다시 의사소통을 해야 했던 적도 있었다. 큰 줄기가 매끄럽지 않다면, 미리 의문이 드는 점을 정리해서 기획자에게 전달하고 답변을 듣기도 했다. 그리고 이 모든 과정에서 나는 잘하고 있는지에 대한 의문이 들 때도 있었다. 기획서가 없어서, 뭔가가 안 되어있어서 등 여러 불만이 생길 때도 있었고, 주변 개발자들에게서 그런 말들을 들을 때도 많았는데 여기서 애자일하게 개발할 수 있는 건 어떤 것일까? 관련 책을 읽어봐야겠단 생각이 좀 들었다. 나는 누군가 '애자일하게 하려면 이 경우에는 이렇게 가시는 게 좋을 것 같아요' 같은 말들을 기대했던 것 같다. 

요구사항의 구렁텅이 파트는 읽으면서 현실에서 얼마나 잘 녹여낼 수 있을지 걱정되기도 했다. 과연 가능한 것인가? 때에 따라 너무 달라서 맞는 말 같기도, 모호하게 느껴지기도 했다. 어쩌면 내가 바뀌어야 하거나, 이 책 초반에 나왔던 '당신의 조직을 바꾸거나, 당신의 조직을 바꿔라.'는 말과 이어질지도 모른다. 경험이 더 많이 필요한 것일 수도 있을 것 같다. 

이번 파트들은 개발자로서 프로젝트에 참여할 때 생길 수 있을 만한 것들에 대한 조언이었는데, 페어 프로그래밍 파트가 재밌을 것 같다. 물론, 책에서도 적혀있듯 '인간적인 측면'도 고려해야 하는데 이런 부분에 대한 불안이 없다면 거짓말이다. 그러나 시도해보지 않으면 나아갈 수도 없을 것이고, 마침 관련 얘기가 나왔던 적이 있어서 일하면서 경험해보면 좋을 것 같단 생각이 들었다. 이 책을 읽으면서 내내 들었던 생각이지만, 기술적으로도 나아가야 하고, 협업하는 팀원으로서도 성장해야 한다는 점이 때로는 답답하기도 하고 때로는 동기부여가 되기도 했다. 배움에는 정말 끝이 없는 것 같고, 겸손해야 할 수밖에 없겠단 생각이 든다. 


## 3. 궁금한 내용 
* [유저 스토리는 무엇인가?](https://yozm.wishket.com/magazine/detail/754/)
* [사용자 스토리 포인트로 스마트하게 프로젝트 진행하기(feat. LINE Pay 개발 팀)](https://engineering.linecorp.com/ko/blog/user-story-point-in-line-pay-team/)


## 4. 참고 도서
* 로버트 C. 마틴, <클린 애자일>
* 마이크 콘, <사용자 스토리>
* 제프 패턴, <사용자 스토리 만들기>