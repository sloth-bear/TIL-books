# Today I Learned
| 구분  | 내용                |
|------|--------------------|
| DATE | 2022.05.17         |
| PART | 3. The Basic Tools |


## 1. 기억하고 싶은 내용
많은 신참 프로그래머가 예컨대 특정 통합 개발 환경(IDE) 같은 강력한 도구 하나만 고집하는 실수를 저지르고, 그 익숙한 인터페이스에서 떠날 생각을 하지 않는다. 정말로 안타깝다. 여러분은 IDE가 갖는 한계를 넘어설 수 있어야 한다. 유일한 방법은 기본 도구들을 언제나 곧바로 사용할 수 있도록 예리하게 유지하는 것이다. 

* 기본 재료: 일반 텍스트
* 작업대: 명령어 셸, 에디터 
* 조작: 에디터 

### 1.1. 일반 텍스트의 힘 
* 실용주의 프로그래머로서 우리의 기본 재료는 나무나 쇠가 아니라 지식이다. 우리가 수집하는 요구 사항은 지식이고, 우리는 그 지식을 설계와 구현, 테스트, 문서로 표현한다. 그리고 우리는 지식을 저장하는 최고의 포맷이 일반 텍스트`plain text`라고 믿는다. 일반 텍스트를 사용하면 수작업으로든 프로그램으로든 동원 가능하 ㄴ거의 모든 도구로 지식을 다룰 수 있게 된다. 일반 텍스트는 인쇄 가능한 문자로 이루어지고, 정보를 전달하기에 적합한 형식을 갖추어야 한다. 쇼핑 목록처럼 간단할 수도 있다. 우리가 만드는 일반 텍스트는 사람이 이해할 수 있어야 한다. 
```
* milk
* onion 
* coffee
```

* 일반 텍스트가 형식이 없는 텍스트를 의미하는 것은 아니다. `HTML`, `JSON`, `YAML` 등은 모두 일반 텍스트다. `HTTP`, `SMTP`, `IMAP` 등 인터넷에서 사용되는 핵심 프로토콜도 대부분 일반 텍스트다. 이렇게 일바 텍스트가 널리 쓰이는 이유는 다음과 같다. 
  * 지원 중단에 대한 보험 
  * 기존 도구의 활용 
  * 더 쉬운 테스트 


* 버전 관리 시스템에서 에디터, 명령 줄 도구에 이르기까지 컴퓨터 세계의 거의 모든 도구는 일반 텍스트를 다룰 수 있다. 예를 들어, 대형 애플리케이션을 설치해야 하는데 복잡한 설정 파일이 설치 장소마다 달라진다고 가정하자. 만약 설정 파일이 일반 텍스트로 되어 있다면 그것을 버전 관리 시스템에 넣을 수 있을 것이다. 그러면 버전 관리 시스템이 모든 변경 기록을 자동으로 보존해줄 것이다. `diff`, `fc` 같은 파일 비교 도구를 사용하면 뭐가 바뀌었는지 단번에 알 수 있고, sum으로는 체크섬`checksum`을 생성해서 파일이 우연히 혹은 악의적으로 변경되지는 않는지 감시할 수 있다. ... 사실 다양한 시스템이 섞인 환경에서는 일반 텍스트의 장점이 다른 모든 단점을 보상하고도 남는다.


### 1.2. 셸 가지고 놀기 
* 텍스트 파일을 다루는 프로그래머에겐 명령어 셸이 작업대다. 셸 프롬프트에서 모든 종류의 도구를 불러다 쓸 수` 있다. 파이프를 이용해 원 개발자가 꿈도 꾸지 못했을 방식으로 도구를 결합할 수도 있다. 셸에서 응용 프로그램이나 디버거, 브라우저, 에디터, 유틸리티를 실행할 수 있다. 파일을 검색할 수 있고, 시스템의 상태를 조회할 수 있으며, 출력을 필터링할 수 있다. 또한 셸을 프로그래밍해서 자주 수행하는 작업을 수월하게 해 주는 복잡한 매크로 명령을 만들 수도 있다. GUI와 IDE를 사용하며 자란 프로그래머들에게 이건 좀 극단적으로 보일지도 모른다. GUI는 훌륭한 것이고, 몇 가지 간단한 조작에서는 더 빠르고 편리할 수도 있다. 

* 그러나 모든 작업을 GUI로만 하면 여러분이 가진 환경의 능력을 저눕 이용할 수 없다. 일반적인 작업을 자동화할 수 없고, 가용한 도구의 역량을 온전히 사용할 수 없다. 게다가 도구를 결합해서 자신에게 꼭 맞는 매크로 도구를 만들 수 없다. 셸에 익숙해지면 여러분의 생산성이 급상승할 것이다. 

* 개발자도 셸을 자신에게 맞추어야 한다. 보통 다음 사항들을 바꾼다. 
  * 색깔 조합 설정 
  * 프롬프트 설정: directory path, vcs status, time, etc...
  * 별칭`alias`과 셸 함수: ex) `alias apt-up = 'sudo apt-get update && sudo apt-get  upgrade`
  * 명령어 자동 완성: 탭 키, 확장하면 명령어 인식해 자동 완성 


* 새 환경으로 옮겨갈 때면 언제나 어떤 셸을 사용할 수 있는지 먼저 알아보라. 기존에 사용하던 셸을 그대로 이용할 수 있는지 확인하라.


### 1.3. 파워 에디팅 
* 텍스트는 프로그래밍의 기본 원재료이므로 여러분은 텍스트를 최대한 손쉽게 조작할 수 있어야 한다. <strong>에티더를 유창하게`fluency` 쓸 수 있게 하라.</strong> 시간을 절약할 수 있는 것도 좋다. 그러나 가장 큰 이점은 더는 에디터 사용법을 생각하지 않아도 된다는 것이다. 뭔가를 생각하는 것에서 에디터 화면에 그게 뜰 때까지의 거리가 확 줄어든다. 생각이 자유롭게 흐를 것이고 프로그래밍에 큰 도움이 될 것이다. 모든 동작을 일일이 생각하면서 운전하는 초보 운전자와 의식하지 않고 차를 모는 경험 많은 운전자는 완전히 다르다. 

* 어떤 것이 유창한 것인가? 아래 과제들을 마우스나 트랙패트 없이 모두 수행할 수 있는가? 
  * 텍스트를 편집할 때 문자, 단어, 줄, 문단 단위로 커서를 이동하거나 내용을 선택하라. 
  * 코드를 편집할 때 반대쪽 괄호로 이동하거나, 함수, 모듈 등 다양한 문법 단위로 커서를 이동하라. 
  * 변경한 코드의 들여쓰기`indent`를 자동으로 맞춰라. 
  * 여러 줄의 코드를 명령 하나로 주석 처리 했다가 해제하라. 
  * 실행 취소를 여러 번 했다가 취소한 명령을 재실행 기능으로 다시 수행하라. 
  * 에디터 창을 여러 구역으로 쪼개라. 그리고 각 구역 사이를 이동하라. 
  * 특정 줄 번호로 이동하라. 
  * 여러 줄을 선택한 후 가나다순으로 정렬하라. 
  * 문자열로, 또 정규 표현식으로 검색하라. 이전에 검색했던 것을 다시 검색하라. 
  * 선택 영역이나 패턴 검색을 이용하여 일시적으로 여러 개의 커서를 만든 다음, 동시에 여러 곳의 텍스트를  편집하라. 
  * 현재 프로젝트의 컴파일 오류를 표시하라. 
  * 현재 프로젝트의 테스트를 실행하라. 


### 1.4. 버전 관리 
* 버전 관리 시스템은 일종의 거대한 '실행 취소' 키와 같다. 이 정도가 VCS 사용의 전부인 이들이 많을 것이다. 하지만 그렇다면 공동 작업과 배포 파이프라인, 이슈 추적에다 일반적인 팀 상호작용까지 아우르는 훨씬 더 큰 세상을 놓치고 있는 것이다. 

* 버전 관리 시스템은 실수를 되돌리는 것 외에도 아주 많은 일을 한다. 좋은 VCS를 사용하면 변경 사항을 추적하여 다음과 같은 질문에도 답할 수 있다. 코드의 이 줄을 누가 바꿨을까? 현재 버전과 지난주 버전은 어디가 다랄졌나? 이번 릴리스에 코드를 몇 줄이나 바꿨을까? 어느 파일이 가장 자주 바뀌나? 이런 종류의 정보는 버그 추적이나 감사`audit`, 성능 관리, 품질 관리를 해야 할 때 매우 귀중하다. 

* 혼자서 한 주짜리 프로젝트를 진행하는 경우일지라도, 나중에 '버리기로 한' 프로토타입일지라도, 심지어 여러분이 작업하는 것이 소스 코드가 아닐지라도, 모든 것을 버전 관리 아래에 둬라. 


### 1.5. 디버깅  
* 실마리 찾기 - 버그를 살펴보기 전에 일단 작업 중인 코드가 경고 없이 깨끗하게 빌드되는지부터 확인하라. 우리는 늘 컴파일러의 경고 수준을 최고로 높게 맞춘다. 컴퓨터가 대신 찾아 줄 수 있는 문제를 여러분이 찾느라 시간을 허비하는 건 말도 안 된다. 우리는 당면한 더 어려운 문제에 집중해야 한다. 

* 디버깅 전략 - 버그 재현하기: 버그를 고치는 첫걸음으로 가장 좋은 것은 그 버그를 재현할 수 있게 만드는 것이다. 여러 단계를 거쳐야만 비로소 버그를 재현할 수 있다면 좀 부족하다. 버그가 발생하는 상황을 다른 것들로부터 분리하다 보면 어떻게 고쳐야 할지에 대한 통찰을 얻기도 한다. 

* 이상한 결과 - 애초에 이 값이 왜 잘못 들어있는지 알아내려면 더 깊이 살펴봐야 하는 경우가 많다. 디버거에서 호출 스택 위아래로 어떻게 이동하고, 스택의 지역 변수를 어떻게 확인하는지 숙지하라. 가끔은 영원히 스크롤 해야 할 것 같은 긴 스택 트레이스`stack trace`를 만날 때가 있다. 이런 때는 스택 프레임을 일일이 조사하는 것보다 더 빠른 바업ㅂ이 있다. 바로 '이진 분할`binary chop`'을 하는 것이다. 

* logging, tracing - 작은 진단용 메시지를 일컫는다. 때ex) `log.info('x = {}', 2)`, `console.log('xxxx')` 로 시간에 따라 프로그램이나 데이터 구조의 상태가 변하는 것을 관찰해야 할 때가 있다. 특히 이벤트 기반 시스템에서는 더하다. 

* 고무 오리 - 누군가에게 설명하기 

* 소거법 - 외부 라이브러리에 문제가 있는 것보다는 개발하고 있는 애플리케이션 코드에 버그가 존재할 가능성이 훨씬 더 크다. 


### 1.6. 텍스트 처리 
* 프로그래밍에서 텍스트 처리 언어는 목공에서 'router'와 같다. 제대로 사용하기만 한다면 루터와 텍스트 처리 언어 둘 다 믿기 힘들 정도로 강력하고 쓰임새가 다양하다. 하지만 숙달하는 데에는 시간이 걸린다. 유닉스나 맥을 사용하는 개발자들은 명령어 셸의 능력을 즐겨 활용하는 경우가 많은데, 여기에 `awk`나 `sed`와 같은 도구를 결합하여 사용하기도 한다. 좀 더 체계적인 도구를 선호하는 사람들은 파이썬이나 루비 같은 프로그래밍 언어를 더 좋아한다. 


### 1.7. 엔지니어링 일지 
* 우리도 일지를 사용한다. 회의에서 메모할 때나 작업하는 내용을 써 놓을 때, 디버깅하다가 변수의 값을 적어 놓을 때, 무엇을 어디 두었는지 기록을 남길 때, 엉뚱한 생각을 기록할 때, 아니면 때로는 그냥 낙서할 때 일지를 쓴다. 기억보다 더 믿을 만하다. 또한 진행 중인 작업과 직접적인 관계가 없는 발상을 일단 쌓아 놓을 수 있는 곳이 생긴다. 그리고 고무 오리와 같은 역할을 할 수도 있다. 


## 2. 소감
갈 길이 구만 리라는 생각을 했다. 툴은 잘 쓰기 위해서 단축키를 여러 개 외우고 있긴 한데, 아직 잘 모르겠는 부분들이 있어서 하나씩 연습해나가야 할 것 같다. 무엇보다 일반 텍스트는 그냥 텍스트라는 생각을 했었는데, Parsing하기에도 쉽고, 무엇보다 어떤 곳에도 종속되지 않고 쉽게 전달할 수 있는 텍스트라는 점이 인상 깊었다. 그리고 되도록 셸과 익숙해지려고 자주 써보고 있는데, git도 history나 graph를 볼 때가 아니면 cli를 자주 사용하려 노력하는 편이다. 다만 alias를 활용하는 건 생각을 해보지 못했다. 당장 내일 alias부터 등록해야겠다. compile warning 수준도 높일 수 있다면 높여보고 말이다. 여전히 익숙하지 않은 내용이나 도구들도 눈에 띈다. 연습문제도 사실 많이 어려워보인다. 그렇지만 막상 해보면 별 거 아닐 수도 있다. 쉽지만은 않은 내용들이 많아서, 연습문제는 풀만한 건 손으로 쓰고 있으나 어려운 건 우선 전체를 한 번 읽은 후에 2회독 때 해보면 좋을 것 같다. 


## 3. 궁금한 내용 
* [Mac - diff 커맨드를 통해 텍스트 파일 다른 부분 골라내기](https://macinjune.com/all-posts/mac/tip/%EB%A7%A5%EB%B6%81-macos-diff-%EC%BB%A4%EB%A7%A8%EB%93%9C%EB%A5%BC-%ED%86%B5%ED%95%B4-%ED%85%8D%EC%8A%A4%ED%8A%B8%ED%8C%8C%EC%9D%BC-%EB%8B%A4%EB%A5%B8-%EB%B6%80%EB%B6%84-%EA%B3%A8%EB%9D%BC/)
* [How to use FC (File Compare) from windows Command Prompt](https://worldrepublicnews.com/how-to-use-fc-file-compare-from-windows-command-prompt/)
* [IntelliJ - Compiler](https://stackoverflow.com/questions/47476471/how-do-i-always-view-a-list-of-compiler-warnings-in-intellij-idea)
* IntelliJ - multi cursor shortcut: Shift + Option + 위 방향키 
* Vs Code - multi cursor shortcut: Shift + Option + Cmd + 아래 방향키 
* [Stack trace](https://ko.wikipedia.org/wiki/%EC%8A%A4%ED%83%9D_%EC%B6%94%EC%A0%81)