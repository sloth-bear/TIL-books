# Today I Learned
| 구분  | 내용                     |
|------|-------------------------|
| DATE | 2022.05.16              |
| PART | 2. A Pragmatic Approach |


## 1. 기억하고 싶은 내용
### 1.1. 좋은 설계의 핵심 
* 좋은 설계는 나쁜 설계보다 <strong>"바꾸기 쉽다."</strong>

* 잘 설계된 코드는 바뀜으로써 "사용하는 사람"에게 맞춰져야 한다. 

* 따라서 ETC 원칙을 따른다. Easier to Change. ETC는 규칙이 아니라 가치다. 가치는 결정을 내리게 도움을 주는 것이다. 스스로에게 계속 질문하라. "내가 방금 한 일이 전체 시스템을 바꾸기 쉽게 만들었을까, 어렵게 만들었을까?"

* 왜 단일 책임 원칙이 유용한가? 요구 사항이 바뀌더라도 모듈 하나만 바꿔서 반영할 수 있기 때문이다. 왜 이름 짓기가 중요한가? 이름이 좋으면 코드가 읽기 쉬워지고, 코드를 바꾸려면 코드를 읽어야 하기 때문이다. 

* 모든 코드는 교체할 수 있게 작성해야 한다. 즉, 코드의 결합도를 낮추고 응집도를 높이라는 이야기일 뿐이다. 

* 현재 상황과 선택, 그리고 변경 사항에 대한 추측을 정리해 두어라. 나중에 이 코드를 바꿔야 하는 시점이 왔을 때, 뒤를 돌아보고 자신에게 피드백을 줄 수 있을 것이다. 이 장의 나머지 항목들은 구체적인 아이디어를 다룬다. 하지만 모두 이 하나의 원칙에 바탕을 둔 것이다. 

### 1.2. 중복의 해악
* 지식은 변화한다. ... 이러한 불안정성은 모두 우리가 소위 유지 보수 모드에서 시스템에 반영된 지식을 재조직하고 다시 표현하면서 대부분의 시간을 보내게 되리라는 것을 의미한다. ... 유지 보수를 하려면 애플리케이션에 표현되어 있는 지식을 찾아내고 또 바꿔야 한다. 문제는 명세와 프로세스, 개발하는 프로그램 안에 지식을 중복해서 넣기 쉽다는 것이다. 그렇게 된다면 애플리케이션이 출시되기 한참 전부터 유지 보수의 악몽이 시작될 것이다. 

* 개발을 이해하고 유지 보수하기 쉽게 만드는 유일한 길은 DRY 원칙을 따르는 것이다. Don't Repeat Yourself. 반복하지 말라. 이를 따르지 않으면 똑같은 것이 두 군데 이상에 표현될 것이다. 하나를 바꾸면 나머지도 바꿔야 함을 "기억"해야 한다. 

* 소스 코드의 복사 붙여넣기만 지양하자는 것이 아니다. "지식", "의도"의 중복에 대한 것이다. 똑같은 개념을 다른 곳 두 군데에서 표현하면 안 된다는 것이다. 

* 모든 코드 중복이 지식의 중복은 아니다. 우연히 규칙은 같을 수 있다. 그러나 표현하고자 하는 지식이 다르다면, 이것은 우연이지 중복이 아니다. 예를 들면, 연령과 주문 수량을 검증하는 로직은 spec이 유사할 수 있다. 그러나 이것은 중복이 아니다. 표현하고자 하는 지식이 다르기 때문이다. 

* 코드에 주석을 남기는 것은 함수의 의도를 두 번 표현한 것이다. 시간이 지남에 따라 주석과 코드의 내용이 서로 어긋나게 될 거라고 거의 확실히 장담할 수 있다. 함수 이름이 함수가 하는 일을 알려준다. 더 자세한 것을 알고 싶다면 소스 코드를 보면 된다. 이것이 DRY다. 

* 자료 구조는 지식을 표현한다. 그리고 DRY를 위배할 수 있다. 예를 들면, 출발과 끝을 가진 `Line`에서 length라는 필드가 존재한다면, 그 역시 DRY가 위배된 것이다. length는 출발과 끝을 가지고 계산할 수 있다. length는 계산되는 필드로 만드는 편이 낫다. 

* 개발을 진행하다 보면 나중에는 성능상의 이유로 DRY 원칙을 위배할 수도 있을 것이다. 비용이 많이 드는 연산을 여러 번 수행하지 않기 위해 데이터를 캐싱할 때 종종 이런 일이 생긴다. 요령은 중복의 영향을 국소화 하는 것이다. 바깥세상에는 DRY 원칙 위배를 노출하지 않는다. 대신 클래스 내의 메서드가 좀 고생하면 된다. 저장한 값으로 구현되었건, 계산을 통해 구현되었건 상관없이 일관된 표기법으로 사용할 수 있어야 한다. 

### 1.3. 직교성
* 직교성은 설계와 빌드, 테스트, 확장이 쉬운 시스템을 만드는 데에 매우 중요한 개념이다. 컴퓨터 과학에서 이 용어는 일종의 독립성이나, 결합도 줄이기를 의미한다. 

* 관련 없는 것들 간에 서로 영향이 없도록 하라. 직교적인 시스템을 작성하면 두 가지 큰 장점이 있다. 바로 생상성 향상과 리스크 감소다. 상대적으로 작고, 자족적인 컴포넌트들을 작성하는 것이 하나의 커다란 코드 덩어리를 만드는 것보다 더 쉽다. 간단한 컴포넌트는 설계하고, 코딩하고, 테스트하고, 그러고는 "잊어버릴 수 있다."

* 직교적인 접근법은 재사용도 촉진한다. 컴포넌트에 명확하고 잘 정의된 책임이 할당되어 있으면 애초에 구현자가 예상하지 못한 방식으로 새로운 컴포넌트와 결합할 수 있다. 시스템이 더 느슨하게 결합되어 있을 수록 재조합하고 결합하기 쉽다. 

* 감염된 코드가 격리되어있다. 어떤 모듈이 병에 걸렸다 해도 시스템의 나머지 부분으로 증상이 전파될 확률이 낮다. 

* 코드의 결합도를 줄이고, 전역 데이터를 피하라. 유사한 함수를 피하라. 중복 코드는 구조에 문제가 있다는 징후다. 시작과 끝은 동일한 코드를 사용하지만, 중간의 알고리즘이 다를 경우, 대신 전략 패턴을 사용하여 더 낫게 구현할 수는 없는지 고민해보라.

### 1.4. 가역성 
* 아키텍처의 모범 사례는 계속해서 변하고 있다. 이렇게 변덕스러운 환경에서 어떻게 계획을 세울 수 있겠는가? 할 수 있는 것은 바꾸기 쉽게 만드는 것이다. 외부의 API를 여러분이 만든 추상화 계층 뒤로 숨겨라. 코드를 여러 컴포넌트로 쪼개라. 

### 1.5. 예광탄
* 익숙하지 않은 알고리즘, 기술, 언어, 라이브러리를 사용하기도 하므로, 여러분은 수많은 미지의 것과 맞닥트리게 된다. 프로젝트가 끝나기 전에 여러분의 작업을 둘러싼 환경이 변하리라는 것도 거의 장담할 수 있다. 실용주의 프로그래머는 소프트웨어 판 예광판을 선호한다. 빨리, 눈에 보이게, 반복적으로 도달하게 해 줄 무언가를 찾아야 한다. 시스템을 정의하는 중요한 요구 사항을 찾아라. 의문이 드는 부분이나 가장 위험이 커 보이는 곳을 찾아라. 이런 부분의 코드를 가장 먼저 작성하도록 개발 우선순위를 정하라.

* 예광탄 개발 방법은 점진적인 접근 방법이다. 사용자는 뭔가 작동하는 것을 일찍부터 보게 된다. 

* 예광탄은 지금 맞히고 있는 것이 무엇인지 보여준다. 그러나 그것이 꼭 목표물이라는 보장은 없다. 그럴 경우 목표물에 맞을 때까지 조준을 옮겨야 한다. 이것이 핵심이다. 

### 1.6. 프로토타입과 포스트잇 
* 프로토타이핑으로 조사할 대상은 무엇인가? 위험을 수반하는 모든 것이다. 이전에 해 본 적이 없는 것, 최종 시스템에 매우 중요한 것이 프로토타이핑 대상이다. 증명되지 않았거나, 실험적이거나, 의심이 가는 것, 마음이 편하지 않은 것 모두가 프로토타이핑의 대상이 될 수 있다. 

### 1.7. 도메인 언어 
* 모든 언어는 제각기 일련의 특징들을 내세운다. 이런 특징들은 모두 어떤 해결 방안을 제시하기도 하지만 가려버리기도 한다. 거꾸로 문제 도메인의 언어가 어떤 프로그래밍 해결방안을 제안하기도 하는데, 우리 생각에는 이것이 프로그래밍 언어의 사고방식보다 더 중요하다. 

* 우리는 언제나 애플리케이션 도메인의 어휘를 사용해서 코드를 작성하려고 노력한다. 실용주의 프로그래머라면 어떤 경우에는 한 차원 더 나아가서 그 도메인의 실제 어휘와 문법, 의미론을 사용해서 프로그래밍할 수도 있다. 

* RSpec과 피닉스 라우터는 이들을 구현하는 호스트언어인 루비와 엘릭서로 원하는 내용을 쓴다. 메타프로그래밍이나 매크로를 포함하여 꽤 색다른 문법을 사용하지만 결국에는 컴파일하고 실행할 수 있다는 코드일 뿐이다. 큐컴버 테스트나 앤서블 명세는 그들 자체의 언어를 사용한다. 큐컴버는 큐컴버 테스트를 코드 혹은 데이터 구조로 변환하여 사용한다. 앤서블은 언제나 앤서블 명세를 자체 데이터 구조로 변환한 후 실행시킨다. 결과적으로, RSpec이나 피닉스 라우터 언어는 여러분이 실행시키는 "코드" 안으로 들어간다. 도메인 언어가 원래 코드의 어휘를 진짜로 확장시키는 것이다. 큐컴버와 앤서블 언어는 별도의 코드가 이 언어를 읽어 들여서 사용할 수 있는 형태로 바꾼다. 우리는 RSpec이나 피닉스 라우터 같은 경우를 '내부 도메인 언어', 큐컴버나 앤서블 같은 경우를 '외부 언어'라고 부른다.

### 1.8. 추정 
* 추정하는 법을 배우고 추정 능력을 계빨하여 무언가의 규모를 직관적으로 짚을 정도가 되면, 추정 대상의 가능성을 가늠하는 마법과 같은 능력을 발휘할 수 있게 될 것이다. 누군가 "우리는 백업한 것을 네트워크로 S3에 전송할 것입니다."라고 이야기할 때, 직관적으로 이것이 가능한지 판단할 수 있게 된다. 

* 모든 추정치는 문제의 모델에 기반한다. 이미 그 일을 해본 사람에게 물어보라. 모델 작성에 너무 시간을 많이 쏟기 전에, 과거에 비슷한 상황에 처했던 사람이 없는지 주변 사람들에게 문의해 보고, 그들이 어떻게 문제를 해결했는지 알아보자. 똑같은 일을 해 본 사람을 찾기는 어렵겠지만, 놀라울 정도로 자주 다른 사람의 경험을 바탕으로 성공적인 추정치를 낼 수 있을 것이다. 

## 2. 소감
이번 장을 읽으면서 ETC와 DRY의 개념만이라도 체화하고 넘어간다면 적어도 어제의 나보다 성장할 수 있을 것이란 생각이 들었다. 
좋은 설계에 관한 접근 방법들을 쭉 소개하고 있지만, 솔직하게 이야기하면 후반으로 갈수록 개념이 다소 난해해지만서 사실 이론적으로만 와닿기도 했다. 

평소 개발하면서 다른 사람이 만든 코드들을 접하고 유지보수하게 될 때가 있는데, 이해가 어려우면 코드의 처음부터 끝까지 쭉 따라가며 흐름을 해석해야 할 때가 있다. 특히 변수명이나 메서드명과 로직의 차이가 내가 이해하기에 차이가 크면 크다 느낄수록 수렁에 빠져든다. 결국 로직에 집중하면서 한 줄, 한 줄 이해하게 되는데, 이름을 살짝만 바꾸면 더 좋을 텐데, 살짝만 분리하면 좋을 텐데, 싶다가도 그게 순전히 "내 기준"에서라면? 개발자의 의도와는 달라지는 것이라면? 결국 질문의 끝에서 내리는 답은 최대한 내버려두고, 원래 해야 했던 한 줄의 코드를 추가하기로 결정하는 것이다. 
보이스카웃 원칙을 지키기 위해서 내가 만든 코드를 다시 수정해야 할 때는 뭐라도 최대한 개선해보려 애썼다. 그러나 그게 다른 사람의 코드라면 이야기가 조금 다르다. 누가 맞다는 것을 논하는 것이 아니라, 어떻게 하면 보편적으로 이해하기 쉬운 코드가 될지 고민해볼 수 있는 과정이 필요한데 사실 잘 몰라서, 바빠서, 불편해서 등 여러 이유로 이런 것들을 팀 내에서 터놓고 꺼내놓기가 어려운 경우가 많다. 
간혹 마음 맞는 사람이 있을 때 내 고민을 꺼내놓고, 혹은 상대의 이야기를 들으면서 변수명 하나만으로 몇 분을 이야기할 수 있을 때가 재미있긴 했다. 

어찌되었건 이런 식의 태도는 본 책에서 나오는 내용과는 상반된다. 내 개인의 노력도 필요하고, 1장에서 얘기했던 것처럼 당신의 조직을 바꾸거나, 당신의 조직을 바꾸어야 한다는 말로 귀결될 수도 있다. 중복 코드만 해도, 아, 이렇게 하면 안 될 것 같은데 하면서도 고민할 시간에 시간에 쫓겨 구현부터 할 때도 있었다. 다만 책에서 말하는 것처럼, 또 어디서든 중요성이 강조되는 SRP, 그리고 높은 응집도와 낮은 결합도를 위해서는 끊임없이 고민하는 과정들이 필요할 것이다. 어제의 나보다는 성장할 수 있게, 이제는 내 머리속에 ETC, DRY를 욱여넣어야겠다. 

## 3. 궁금한 내용 
* [tracer bullet(예광탄) vs prototype](https://medium.com/@saptanto.sindu/tracer-bullet-vs-prototyping-707dc39204)
* [DSL(Domain Specific Language) 이해하기](https://unabated.tistory.com/entry/DSLDomain-Specific-Language-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0)