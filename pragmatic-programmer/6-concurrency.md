# Today I Learned
| 구분  | 내용            |
|------|----------------|
| DATE | 2022.05.25     |
| PART | 6. Concurrency |


## 1. 기억하고 싶은 내용
동시성(병행성)은 둘 이상의 코드 조각이 실행될 때 동시에 실행 중인 것처럼 행동하는 것이다. 그리고 병렬성`paralleism`이란 실제로 동시에 실행되는 것이다. 동시성을 얻으려면 실행 중에 코드의다른 부분으로 실행을 전환할 수 있는 환경에서 코드를 구동해야 한다. 보통은 파이버`fiber`나 스레드, 프로세스 등을 사용하여 동시성을 구현한다. 벙렬성을 얻으려면 두 가지 일을 동시에 할 수 있는 하드웨어가 필요하다. CPU 하나에 있는 여러 개의 코어일 수도 있고, 컴퓨터 한 대에 있는 여러 CPU이거나 아니면 네트워크로 연결된 여러 대의 컴퓨터일 수도 있다. 

개발자들은 코드 간의 결합에 대하여 자주 이야기한다. 주로 입에 오르는 것은 의존성, 그리고 이런 의존성이 어떻게 코드를 바꾸기 힘들게 하는지다. 그런데 또 다른 형태의 결합이 있다. 시간적 결합`temporal coupling`은 당면한 문제 해결에 꼭 필요하지 않은 일 처리 순서를 코드가 강제할 때 생긴다. "딱" 전에 "똑"이 울린다는 사실에 의존하고 있는가? 유연해지려면 그래서는 안 된다. 여러분의 코드가 여러 백엔드 서비스에 한 번에 ㅎ나씩 순차적으로 접근하는가? 고객을 지키고 싶다면 그래서는 안 된다. 

동시성이나 병렬성을 지원하는 코드를 쓰는 건 왜 그렇게 어려울까? 한 가지 이유는 우리가 프로그래밍을 순차적 시스템으로 배워서다. 그리고 우리가 쓰는 언어의 기능이 순차적으로 사용할 때는 비교적 안전하지만, 동시에 두 가지 일이 일어날 수 있으면 골칫거리로 변해서다. 가장 큰 문제는 공유 상태`shared state`다. 단순히 전역 변수만을 이야기하는 것이 아니다. 둘 이상의 코드 뭉치가 하나의 변경 가능한 데이터를 참조하고 있다면 공유 상태가 존재하는 것이다. 그리고 공유 상태는 틀린 상태다. 몇 가지 우회 방법을 설명하겠지만 결국에는 모두 잘못되기 쉽다. 

동시성을 갖춘 애플리케이션을 구축하는 더 나은 방법들이 있다. 액터`actor` 모델이 그 중 하나다. 그리고 '칠판'을 살펴본다. 칠판은 객체 저장소와 똑똑한 publish-subscribe broker를 합한 것처럼 동작하는 시스템이다.칠판 본래의 형태로는 널리 사용되지 못했지만, 요즘은 칠판과 유사한 방식으로 동ㅇ작하는 미들웨어 계층 구현이 점점 더 눈에 많이 띈다. 제대로 사용한다면 칠판과 같은 유형의 시스템으로 결합을 대폭 줄일 수 있다. 

### 1-1. 시간적 결합`temporal` 깨트리기 
* 시간적 결합이란 무엇인가? 시간에는 우리가 신경 써야 할 측면이 두 가지 있다. 
  * 동시성: 동시에 일어나는 일들 
  * 순서: 시간의 흐름 속에서 일들의 상대적인 위치 
* 메서드 A는 B보다 먼저 호출되어야 하고, 버튼 클릭을 처리하려면 먼저 화면이 갱신되어야 한다. 이러한 접근 방법은 그다지 유연하지 않고 현실과도 동떨어져 있다. 동시성을 확보해야 한다. 시간이나 순서에 의존하는 시간적 결합을 끊는 방법을 생각해내야 한다. 
* 활동 다이어그램`activity diagram` 같은 표기법을 사용해 작업 흐름을 기록하는 것이 한 방법이다. (UML이 사라져가고 있긴 하지만 말이다. 활동 다이어그램도 그 중 하나다.)
  * 동기화 막대 표기
  * 동시에 수행할 수 있는데도 동시에 하고 있지 않은 활동들을 찾아내 병렬성을 극대화 할 수 있다.
  * 동시에 작업할 수 있는 부분들은 볼 수 있지만, 그게 좋은지는 알 수 없으므로 설계가 필요하다.

### 1-2. 공유 상태`shared state`는 틀린 상태 
* 두 프로세스가 같은 메모리 영역에 쓰기가 가능하다는 점이 문제가 아니다. 문제는 어느 프로세스도 자신이 보는 메모리가 일관되어 있음을 보장할 수 없다는 점이다. 값을 가져오는 것이 실제로는 자신의 메모리로 복사하는 것이고, 만약 값이 바뀐다면, 결정에 사용한 메모리는 시효가 지난 것이다. 동작이 atomic 하지 않기 때문이다. 실제 값이 그 사이에 바뀔 수 있다. 
* 셰마포어`semaphore`는 단순히 한 번에 한 사람만이 가질 수 있는 무언가다. 전통적으로는 셰마포어를 획득하는 작업을 'P'로, 반환하는 작업을 'V'로 불렀지만 요즘은 '잠금`lock`/잠금 해제`unlock`', '획득`claim`/반환`release`' 등으로 부른다. 
  ```
  case_semaphore.lock()

  if display_case.pie_count > 0
    promise_pie_to_customer()
    display_case.take_pie()
    give_pie_to_customer()
  end

  case_semaphore_unlock()
  ```
  두 프로세스가 동시에 접근한다고 가정하자. 둘 다 세마포어를 얻으려고(lock) 시도하지만 한 명만 성공한다. 얻지 못한 쪽은 얻을 수 있을 때까지 기다린다. 이 접근 방식에는 몇 가지 문제가 있다. 가장 큰 문제는 모든 사람이 빠짐없이 세마포어를 사용해야만 제대로 동작한다는 것이다. 만약 누군가가 깜빡한다면, 다시 말해서 어떤 개발자가 약속을 지키지 않는 코드를 쓴다면 다시 혼돈에 빠진다. 
* 이 제어를 중앙으로 집중시키면 된다. 다만, 예외가 발생했을 때도 `unlock`하도록 신경써야 한다. 그렇지 않으면 예외가 발생했을 때 이후로 하염없이 기다리게 될 것이다. 
* 대부분의 언어에는 공유 리소스에 독점적으로 접근하는 것을 도와주는 라이브러리가 있다. 상호 배제`mutual exclusion`를 의미하는 뮤텍스`mutex`라고 부르기도 하고, 모니터`monitor`나 세마포어라고 부르기도 한다. 언어 자체에 동시성 지원이 들어 있는 언어도 있다. 


### 1-3. 액터`actor`와 프로세스 
* 액터`actor`와 프로세스를 사용하면 흥미로운 방식으로 동시성을 구현할 수 있다. 공유 메모리 접근을 동기화하느라 고생할 필요도 없다. 프로세스는 본래 더 일반적인 가상 처리기로, 보통 운영 체제가 동시성을 지원하기 위하여 구현한다. 프로세스를 사용할 때 마치 액터처럼 동작하도록 관례를 만들어 제한적으로만 사용할 수 있는데, 이번 항목에서 이야기하는 프로세스란 바로 이렇게 제한한 것을 말한다.
* 액터`actor`
  * 자신만의 비공개 지역 상태`state`를 가진 독립적인 가상 처리 장치`virtual processor`
  * 각 액터는 우편함`mailbox`을 하나씩 보유하고 있다. 
  * 액터가 잠자고 있을 때 우편함에 메시지가 도착하면 액터가 깨어나면서 메시지를 처리한다. 
  * 메시지 처리가 끝나면 우편함의 다른 메시지를 처리한다. 
  * 우편함이 비어있으면 다시 잠든다. 
  * 메시지를 처리할 떄 액터는 다른 액터를 생성하거나, 알고 있는 다른 액터에게 메시지를 보내거나, 다음 메시지를 처리할 때의 상태가 될 새로운 상태를 생성할 수 있다. 
* 액터를 관리하는 것이 하나도 없다. 다음에 무엇을 하라고 계획 세우거나, 정보를 입력 데이터 -> 최종 결과로 바꾸는 과정을 조율하는 것이 없다. 
* 시스템이 저장하는 상태는 오직 메시지 그리고 각 액터의 지역 상태뿐이다. 메시지는 수신자가 읽는 것 외에는 확인할 방법이 없고 지역 상태는 액터 바깥에서는 접근이 불가능하다. 
* 모든 메시지는 일방향이다. 답장이란 개념은 없다. 답장을 받고 싶다면 처음 메시지를 보낼 때 답장 받을 우편함 주소를 메시지에 포함해서 보내야 한다. 나중에 이 주소로 보내는 답장도 결국 또 하나의 메시지일 뿐이다.
* 액터는 각 메시지를 끝날 때까지 처리하고 중간에 다른 일을 하지 않는다. 즉, 한 번에 하나의 메시지만 처리한다. 
* 그 결과 액터들은 아무것도 공유하지 않으면서 비동기적으로 동시에 실행된다. 물리적인 프로세서가 넉넉하다면 각각 액터를 하나씩 돌릴 수 있다. 프로세서가 하나뿐이라면 실행 환경이 액터마다 컨텍스트를 전환해 가면서 실행시킬 수 있다. 어느 쪽이든 액터에서 실행되는 코드는 동일하다. 


### 1-4. 칠판`blackboard`
* 일종의 자유방임주의적 동시성이다. 독립된 프로세스, 에이전트, 액터 등이 칠판에 수집한 사실을 붙이고, 떼어내고, 조합하거나 처리하고, 더 많은 정보를 덧붙일 수도 있다. 칠판은 사람들이 서서히 결론에 도달하도록 돕는다. 
* 컴퓨터 기반의 칠판 시스템은 원래 음성 인식, 지식 기반 추론 시스템 등 해결해야 할 문제의 규모가 크고 복잡한 인공 지능 애플리케이션에서 사용되었다. 


## 2. 소감
동시성은 책 분량이 많지 않음에도 이틀동안 공부할 시간이 주어졌는데, 역시 어려운 분야다. 책에서도 나오지만 동시성으로 인해 고난의 연속이라면, 그렇게 하지 말라고 이야기한다. 우선 공유메모리를 사용할 때 제대로 해제해주지 않으면 다시 deadlock에 빠지는 부분은 golang에서는 defer를 통해 경험해보긴 했지만, 실제 서비스에서 사용해본 경험이 없어서 와닿지는 않았다. actor와 blackboard 개념들은 역시 어렵기는 하다. 처음 봤을 때는 message broker 가 떠오르기도 했다. 검색해보니 역시 webflux를 사용할 때 관련 내용들이 나오는 것 같다. 이 부분은 조금 더 공부해보고, 코드로 직접 녹여보면서 여러 번 경험해보아야 이해할 수 있을 듯하다.

## 3. 궁금한 내용 
* [Actor Model 패턴의 구현(Java)](https://effectiveprogramming.tistory.com/entry/Actor-Model-%ED%8C%A8%ED%84%B4%EC%9D%98-%EA%B5%AC%ED%98%84Java)
* [Blackboard Pattern](https://itwiki.kr/w/%EC%B9%A0%ED%8C%90%ED%98%95_%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98_%EC%8A%A4%ED%83%80%EC%9D%BC)