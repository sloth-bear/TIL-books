# Today I Learned
| 구분  | 내용                     |
|------|-------------------------|
| DATE | 2022.05.26              |
| PART | 7. While you are coding |


## 1. 기억하고 싶은 내용

### 1-1. 파충류의 뇌에 귀 기울이기
* 새로운 프로젝트를 시작하는 일도 두렵기는 마찬가지다. 심지어 이미 있는 프로젝트에 새로운 모듈을 추가하는 일도 그렇다. 많은 사람이 일을 시작하는 첫 발짝을 미루고 싶어 한다. 

* 첫 번째 원인은 파충류의 뇌가 여러분에게 무언가 할 말이 있어서다. 여러분은 개발자로서 여러 가지를 시도해 보면서 잘 되는 것과 안 되는 것들을 보아 왔다. 어떤 작업을 앞두고 마음 속에 의심이 계속 남아 있거나 왠지 꺼림칙하다면, 여러분의 경험이 여러분에게 말을 거는 중일지도 모른다. 그 느낌을 따라라. 정확하게 짚지는 못하더라도, 시간을 좀 주면 아마 더 실체가 있고 대응책을 생각할 수 있는 무엇으로 구체화 될 것이다.

* 두 번째는 합리적인 두려움이다. 우리 개발자들은 코드에 많은 것을 투자한다. 그래서 코드의 오류를 자신의 부족한 능력 때문이라고 받아들일 수도 있다. 아마 임포스터 증후군의 요소 또한 있을 것이다. 자신의 능력 밖이라 생각할 수도 있다. 우리는 이 길의 끝에 무엇이 기다리고 있는지 모르고, 어쩌면 너무 멀리까지 가버린 후에 사실은 길을 잃었다는 것을 인정하게 될 지도 모른다. 

* 일단 하고 있는 일을 멈추고, 여러분의 뇌가 정리를 좀 할 수 있도록 약간의 시간과 공간을 확보하라. 코드에 대해 생각하지 말고 키보드에서 떨어져서 잠깐 머리를 비운 채로 할 수 있는 일을 하라. 

* 문제를 표면으로 끄집어내 보라. 작성하는 코드에 대한 그림을 그려 보라. 동료에게 설명해 보라. 고무 오리도 괜찮다. 여러분 뇌의 다른 부위에 문제를 노출하라. 

* 이런 방법들을 시도해 보았는데도 여전히 막혀 있을 수도 있다. 행동해야 할 시간이다. 여러분의 뇌에게 여러분이 하려는 일은 별 문제가 없다고 알려줘야 한다. 바로 프로토타이핑을 하면 된다. 


### 1-2-. 우연에 맡기는 프로그래밍
* 단순히 코드가 지금 작성된 방식이 그렇기 때문에 생기는 우연한 일들이 있다. 이런 우연에 기대다 보면 결국 문서화되지 않은 에러나 예외적인 경우의 동작에 의존하게 되고 만다. 예를 들어 어떤 루틴을 잘못된 데이터를 가지고 호출했다고 해 보자. 루틴은 예상하지 못한 데이터에 특정한 방식으로 반응을 하고, 여러분은 그 반응을 기반으로 코드를 작성한다. 하지만 루틴을 만든 사람의 의도는 그 루틴이 그런 식으로 작동하는 것이 아니었다. 만든 사람이 생각조차 못했던 경우인 것이다. 이 루틴을 '고치면' 여러분의 코드는 작동을 멈출지도 모른다. 가장 극단적인 경우에는 여러분이 호출한 루틴이 실제로는 그렇게 설계된 루틴이 아닌데도 원하는 효과를 내는 것처럼 보일 수도 있다. 잘 작동하는 데 괜히 건드려서 일을 만들 필요가 있을까? 우리가 보기에는 그래야 할 이유가 몇 가지 있다. 
  * 정말 제대로 돌아가는 게 아닐지도 모른다. 
  * 여러분이 의존하는 조건이 단지 우연인 경우도 있다. 
  * 불필요한 추가 호출은 코드를 더 느리게 만든다. 
  * 추가로 호출한 루틴에 새로운 버그가 생길 수도 있다. 

* 다른 사람이 호출할 코드를 작성하고 있다면 모듈화를 잘하는 것, 그리고 잘 문서화한 적은 수의 인터페이스 아래에 구현을 숨기는 것 같은 기본 원칙들이 모두 도움이 된다. 

* 우리가 일했던 한 대형 프로젝트에서는 외부 현장에 설치된 다수의 데이터 수집 하드웨어로부터 인입되는 데이터를 가지고 보고서를 생성해야 했다. 이 수집 기기들은 미국의 여러 주와 시간대에 걸쳐 설치되어 있었는데, 다양한 프로젝트 진행 과정상의 이유와 과거로부터 이어져 온 이유로 인해 기기는 제각기 현지 시각로 설정되어 있었다. 특정한 경우 '딱' 한 시간 틀리는 것은 우연이었다. 시간을 다루는 적절한 모델이 없었기 때뭉네 점점 말도 안 되는 양의 +1, -1 명령들이 코드 전체에 퍼져 나갔다. 결국 제대로 맞는 값이 없었고, 프로젝트는 폐기되었다. 

* 언제나 사용자가 글을 읽을 수 있다고 생각하는가? 확실한 것이 아닌데도 의존하고 있는 것은 또 무엇이 있을까? 

* 더 경험이 적은 프로그래머에게 코드를 상세히 설명할 수 있는가? 그렇지 않다면 아마 우연에 기대고 있는 것일 터이다. 

* 자신도 잘 모르는 코드를 만들지 말라. 이것이 왜 동작하는지 잘 모른다면 왜 실패하는지도 알 리가 없다. 


### 1-3. 알고리즘의 속도 
* 매우 간단한 몇몇 알고리즘을 제외한 대부분의 알고리즘은 가변적인 입력 데이터를 다룬다. n개의 문자열 정려하기, m x n행렬의 역행렬 만들기, n비트키를 이용해서 메시지 암호화하기 등이 그렇다. 일반적으로 입력의 크기는 알고리즘에 영향을 준다. 입력의 크기가 클수록 알고리즘의 수행 시간이 길어지거나 사용하는 메모리 양이 늘어난다. 이런 관계가 늘 1차 함수처럼 선형적`linear`이라면, 다시 말해 늘어나는 시간이 n에 정비례한다면 이 항목은 그다지 중요하지 않을 것이다. 하지만 <u>중요한 알고리즘은 대부분 선형적이지 않다</u>. 좋은 소식은많은 알고리즘의 증가폭이 선형보다 작다는 것이다. 예를 들어 이진 검색은 일치하는 항목을 찾을 때 모든 후보를 다 살펴볼 필요가 없다. 나쁜 소식은 나머지 알고리즘들은 증가 폭이 선형보다 훨씬 크다는 것이다. 즉, 수행 시간이나 메모리 요구량이 n보다 훨씬 빠르게 늘어난다. 

* 우리는 반복문이나 재귀 호출을 담고 있는 코드를 작성할 때면 언제나 무의식적으로 수행 시간과 필요한 메모리 양을 계산한다. 정신 계산은 아니고, 주어진 호나경에서 우리가 하는 일이 말이 되는지 가볍게 확인해 보는 정도에 가깝다. 하지만 생각보다 훨씬 상세한 분석을 해야 하는 경우도 종종 실제로 있다. 이럴 때 대문자 O 표기법`Big-O notation`이 유용하다.

#### 대문자 O 표기법`Big-O notation`
* 대문자 O 표기법은 근사값을 다루는 수학적 방법으로 O()와 같이 표기한다. 어떤 정렬 루틴이 원소 n개를 정렬하는데 O(n2) 시간이 걸린다고 말할 때, 이는 그저 최악의 경우에 걸리는 시간이 n의 제곱에 비례하여 늘어난다고 얘기하는 것이다. 원소 수가 두 배로 늘어나면 걸리는 시간은 대략 네 배가 된다. O가 '...차수로`order of`'를 뜻한다고 생각하면 된다. 

* 예를 들어 어떤 함수가 O(n2)시간이 걸린다고 하면, 이 말은 이 함수가 실행되는 데 걸리는 시간의 최댓값이 n2보다 더 빨리 늘어나지 않는다는 뜻이다. 

* 상당히 복잡한 O() 함수가 만들어지는 경우도 있는데, n이 커질수록 가장 큰 차수에 비하면 다른 차수는 무시해도 될 정도이기 때문에, 관습적으로 최상위 차수를 제외한 다른 모든 차수는 제거하며, 상수인 계수도 표기하지 않는다. 이것이 O() 표기법의 특징이다. 어떤 O(n2) 알고리즘이 다른 O(n2) 알고리즘보다 천 배나 빠를 수도 있지만 대문자 O표기법만으로는 그 사실을 알 수 없다. 대문자 O 표기법은 수행 시간이든 메모리든, 아니면 다른 무엇을 나타내든 실제 숫자를 알려주지 않는다. 그저 <u>입력의 크기가 바뀜에 따라 이 값이 어떻게 바뀔지</u>를 알려줄 뿐이다.

* 가장 빠른 알고리즘이 언제나 가장 좋은 알고리즘은 아니다. 입력값의 규모가 작다면 단순한 삽입 정렬도 퀵 정렬과 비슷한 성능을 낸다. 그러나 삽입 정렬을 작성하고 디버깅하는 데 걸리는 시간은 퀵 정렬보다 적다. 여러분이 선택한 알고리즘이 요구하는 형식으로 입력 데이터를 준비하는 데 비용이 많이 드는 것은 아닌지 주의 깊게 보아야 한다. 그리고 성급한 최적화 `premature optimization`를 조심하라. 언제나 어떤 알고리즘을 개선하느라 여러분의 귀중한 시간을 투자하기 전에 그 알고리즘이 정말로 병목인지 먼저 확인하는 것이 좋다. 

* 알고리즘을 어떻게 설계하고 분석하는지에 대한 감각이 있어야 한다. 
  * 로버트 세지윅`Robert Sedgewick` - 알고리즘, An Introduction to the Analysis of Algorithms(알고리즘 분석 입문)
  * 도널드 카누스`Donald Knuth` - The Art Of Computer Programming(1~4A)


### 1-4. 리팩터링 

### 1-5. 테스트로 코딩하기 

### 1-6. 속성 기반 테스트 

### 1-7. 바깥에서는 안전에 주의하라

### 1-8. 이름 짓기 


## 2. 소감


## 3. 궁금한 내용 