# Today I Learned
| 구분  | 내용                   |
|------|-----------------------|
| DATE | 2022.05.31            |
| PART | 9. Progmatic Projects |


## 1. 기억하고 싶은 내용 
### 1-1. 실용주의 팀
* 개인이 혼자 실용주의를 따라도 이점이 있지만, 그 개인이 실용주의 팀에서 일한다면 그 이점이 몇 배로 더 커진다. 우리가 말하는 팀은 작고 보통은 그 자체로 안정적인 존재다. 50명은 팀이 아니다. 큰 무리다. 구성원이 계속 다른 업무에 끌려가고, 아무도 서로를 모르는 팀도 사실 팀이 아니다. 실용주의 팀은 작다. 구성원이 대략 10~12명 이하여야 하고, 구성원이 추가되거나 빠지는 일은 드물어야 한다. 

#### 깨진 창문을 없애라 
* 품질은 팀의 문제다. 아무리 부지런한 개발자라 해도 품질에 무심한 팀에 배치된다면, 자질구레하게 계속되는 문제를 고치는 데 필요한 열정을 유지하긴 어려울 것이다. 팀 전체가 깨진 창문을 용납하지 않아야 한다. '깨진 창문을 없애라' 철학을 이해하는 개발자들을 지원하고, 그렇지 못한 개발자들은 이해하도록 독려해야 한다. 

* 몇몇 팀 방법론에는 '품질 관리 담당자'가 있어서 제품의 품질에 대한 책임을 팀에게서 위임받는다. 정말 웃기는 일이다. 품질은 팀원 모두가 제각기 기여할 때만 보장되기 때문이다. 품질은 애초에 제품에 포함된 것이지 나중에 덧붙이는 것이 아니다. 

#### 삶은 개구리 
* 팀은 개인보다 더 삶은 개구리가 되기 쉽다. 사람들은 누군가가 문제를 처리하겠거니 생각하거나, 사용자가 요청한 변경 사항을 팀 리더가 이미 동의했겠거니 하고 여긴다. 제아무리 좋은 뜻을 가진 팀이라도 자기네 프로젝트가 심각하게 변화하는 것에는 둔감할 수도 있다. 

* 이미 일어난 변화를 거부할 필요는 없다. 단지 그런 일이 벌어지고 있다는 것을 파악하고 있으면 된다. 

#### 여러분의 지식 포트폴리오를 계획하라 
* 성공을 원하는 팀이라면 마찬가지로 자신들의 지식과 기술에 투자하는 것을 고려해야 한다. 여러분의 팀이 진정 개선하고 혁신하고 싶다면 계획을 세워야 한다. "시간이 나면 그때" 하겠다는 것은 "영원히 하지 않겠다."는 것이다. 할 일을 백로그로 관리하든 업무 목록이나 업무 흐름 도구를 사용하든 간에 기능 개발로만 몽땅 채우지는 말라. 새로운 기능을 만드는 것 외에도 해야 할 일들이 있다. 
  * 구형 시스템 유지 보수 
  * 프로세스 회고와 개선
  * 새로운 기술 탐험
  * 학습 및 기술 갈고 닦기 

#### 팀의 존재를 소통하라 
* 외부 사람들에게 무뚝뚝하고 과묵해 보이는 프로젝트팀이야말로 최악의 팀이다. 그런 팀의 회의는 아무런 체계가 없고 침문만 가득하다. 

#### 반복하지 말라
* 중복된 일은 노력을 무위로 돌릴 뿐 아니라 결국 유지 보수를 악몽으로 만들 수도 있다. 칸칸이 분리된 연통형`stovepipe` 혹은 사일로형 시스템이 이런 팀들의 모습이다. 이런 팀에서는 공유되는 것이 거의 없고, 중복된 기능은 아주 많다. 좋은 의사소통이 이런 문제를 피하는 핵심이다. 여기서 "좋은"이란 즉각적이고 매끄러운 것을 말한다. 

#### 팀 예광탄
* 프로젝트팀은 프로젝트의 여러 분야에서 수많은 기술을 섭렵하고 다양한 과제를 해결해야 한다. 요구 사항을 이해하고, 아키텍처를 설계하고, 프론트엔드와 서버 코드를 쓰고, 테스트를 돌리는 모든 일을 해내야 한다. 그런데 이런 활동들과 과제들을 독립적으로 따로따로 수행할 수 있을 거라도 많이 오해한다. 하지만 그런 일은 불가능하다. 

* 예광탄을 사용하여, 처음에는 작고 제한적일지라도 시스템의 끝에서 끝까지 전체에 걸쳐 있는 단일 기능을 개발할 것을 추천한다. 처음에는 아무리 작고 제한적인 기능밖에 만들지 못하더라도 말이다. 이 말은 작업에 필요한 기술을 팀 안에 모두 갖추어야 한다는 뜻이다. 프론트엔드, UI/UX, 서버, DBA, QA 등이 모두 함께 일하는 것이 편안하고 익숙해야 한다. 예광탄 접근 방법을 사용하면 기능의 아주 조그만 부분을 아주 빠르게 개발할 수 있다. 

#### 자동화 
* 일관성과 정확성을 모두 보장하는 확실한 방법은 팀이 하는 모든 일을 자동화하는 것이다. 에디터나 IDE가 자동으로 맞춰 주는데 왜 코드 스타일을 신경 쓰는가? 지속적 빌드가 테스트를 자동으로 실행하는데 왜 수동으로 테스트를 돌리는가? 왜 손으로 배포하는가, 자동화하면 매번 반복적으로 확실하게 배포해 줄 텐데? 

#### 멈춰야 할 때를 알라
* 팀은 개인들로 이루어진다는 사실을 명심하라. 각 팀원이 자신의 방식대로 빛나게 하라. 팀원들을 지원하기에, 그리고 프로젝트가 가치를 만들어 내기에 딱 좋을 만큼의 구조를 제공하라. 


### 1-2. 코코넛만으로는 부족하다
* 화물 숭배의 함정은 너무 솔깃해서 빠지기 쉽다. 눈에 잘 띄는 결과물을 만드는 데만 투자하면서 기반이 되는 작업이 마법처럼 끝나 있기를 소망한다. 

* 여러분이나 여러분의 팀이 이런 함정에 빠진 적은 없는가? 자문해 보라. 이 특정한 개발 방법이나 프레임워크, 테스트 기법을 굳이 사용하는 이유가 무엇인가? 정말로 지금 하는 일에 잘 맞아서인가, 자신에게 잘 맞아서인가? 아니면 그저 최근에 인터넷에서 회자된 성공 사례에서 사용했기 때문에 도입한 것인가? 스포티파이나 텟플릭스, 스트라이프, 깃랩 등과 같이 성공한 회사의 정책과 프로세스를 다들 앞다투어 도입하고 있다. 각자 나름의 방식으로 소프트웨어를 개발하고 관리한다. 하지만 맥락을 고려해야 한다. 여러분이 동일한 시장과 동일한 제약 조건을 갖고 있고 비슷한 전문성과 조직 크기, 비슷한 경영진, 비슷한 문화를 보유하고 있는가? 사용자층과 요구사항도 비슷한가? 속아 넘어가지 말라. 특정한 결과물, 피상적인 구조나 정책, 프로세스, 방법론만으로는 부족하다. 

* "잘 맞는 것"을 어떻게 알 수 있을까? 작은 팀 하나나 조직 하나에서 아이디어를 시험해 보라. 잘 맞는 것 같은 좋은 부분만 유지하고 나머지는 낭비나 비용일 뿐이므로 버리면 된다. 여러분의 조직이 스포티파이나 넷플릭스와 다르게 운영된다고 해서 깎아내릴 사람은 아무도 없다. 

* 진짜 목표는 당연히 "스크럼을 한다"나 "애자일을 한다", "린을 한다" 같은 종류가 아니다. 진짜 목표는 작동하는 소프트웨어를 제공함으로써 사용자가 즉각적으로 새로운 일을 할 수 있게 되는 것이다. 

* 지금으로부터 몇 주 후, 몇 달, 몇 년 후가 아니라 지금, 지속적 배포`continuous delivery`가 이상적이지만 도달 불가능한 목표라고 생각하는 팀이나 조직이 많다. 특히 배포를 몇 달 내지 몇 주에 한 번으로 제한하는 프로세스를 따르고 있다면 더 그럴 것이다. 하지만 모든 목표가 그렇듯 계속 올바른 방향을 바라보는 것이 중요하다. 이런 지속적 개발을 도입하려면 매우 견고한 기반 구조`infrastructure`가 필요하다. 여러분은 버전 관리 시스템의 `feature` 브랜치가 아니라 `main` 브랜치-혹은 `trunk`-에서 개발해야 한다. 그리고 사용자에게 선택적으로 시범적 기능을 공개할 때는 '기능 스위치'같은 기법을 활용하라. 

* 특정 방법론에 과도하게 투자하면 다른 대안을 보지 못하게 될 수도 있다. 하나에 고착되면 머지않아 다른 길을 보기 어렵게 된다. 한 가지 방식이 너무 굳어져 버리면 더 이상 빠르게 적응할 수 없게 된다.


### 1-3. 실용주의 시작 도구 
* 빌드와 릴리스 과정이건, 테스트나 프로젝트 서류 작업이건, 혹은 프로젝트에서 거듭 발생하는 다른 어떤 작업이건 간에 일상적인 작업은 모두 자동화해야 한다. 그래서 지원되는 모든 컴퓨터에서 반복 수행할 수 있어야 한다. 수작업은 일관성을 운에 맡긴다. 

#### 버전 관리로 운용하라 
* 프로젝트를 빌드하는데 필요한 모든 것을 버전 관리 하에 두어야 한다. 이는 프로젝트 전체의 관점에서 보면 더 중요하다. 그렇게 하면 빌드 장비를 일시적으로 쓰고 없앨 수 있다. 배포 설정도 역시 버전 관리 시스템 안에 있으므로 실제 서비스에 릴리스하는 것도 자동으로 처리된다. <b>프로젝트 차원에서는 버전 관리 시스템이 빌드와 릴리스 프로세스를 운용한다.</b>

#### 가차 없고 지속적인 테스트
* 코드를 작성하자마자 테스트해야 한다. 작은 잔챙이들은 꽤 빨리 자라나 사람을 잡아먹는 거대한 상어가 되는 고약한 성질이 있다. 그래서 우리는 단위 테스트를 작성한다. 아주 많이. 훌륭한 프로젝트에는 제품 코드보다 테스트 코드가 더 많을 수도 있다. 테스트 코드를 만들기 위해 들이는 시간에는 그 노력 만큼의 가치가 있다. 길게 보면 이쪽이 훨씬 더 싸게 먹히며, 결함이 거의 없는 제품을 만드는 꿈이 정말 이루어지기도 한다. 자동 빌드가 모든 가용한 테스트를 수행한다. "진짜 상황 테스트"를 목표로 하는 것이 중요하다. 즉, 테스트 환경은 실제 환경과 최대한 비슷해야 한다. 두 환경의 차이에서 버그가 번식한다. 

* 빌드 과정에는 소프트웨어 테스트의 몇 가지 주요 유형이 들어가야 한다. 단위 테스트, 통합 테스트, 유효성 평가 및 검증, 성능 테스트가 그것이다. 
  * 단위 테스트`Unit Test`: 하나의 모듈을 테스트하는 코드다. 부분으로 떼어 놓았을 때 제대로 작동하지 않는다면 합쳤을 때도 역시 제대로 작동하지 않을 것이다. 
  * 통합 테스트`Integration Test`: 프로젝트를 구성하는 주요 서브시스템이 다른 부분과 제대로 작동하는지 보여준다. 계약이 제대로 되어 있고, 테스트가 잘 되어 있다면 어떤 통합 문제든 쉽게 발견할 수 있다. 
  * 유효성 평가 및 검증`Validation and Verification`: 사용자들이 필요한 것을 이야기해 주긴 했지만, 그게 정말 사용자들이 필요로 하는 것인가? 시스템의 기능적 요구 사항을 충족하는가? 이것 역시 테스트해 봐야 한다. 버그가 없는 시스템일지언정 잘못된 문제를 푼다면 별 쓸모가 없다. 
  * 성능 테스트`Performance Test` 혹은 스트레스 테스트: 이 역시 프로젝트의 중요한 측면이다. 예상하는 사용자 수나 접속 수 혹은 초당 트랜잭션 숫자를 염두에 두라는 말이다. 

* 코드 전체를 필요한 만큼 철저하게 테스트했다는 것은 어떻게 알 수 있을까? 한마디로 답하자면 "알 수 없다." 긜고 앞으로도 알 수 없을 것이다. 어쩌면 커버리지 분석 도구를 적용해볼지도 모르겠다. 커버리지 분석 도구는 테스트 중에 코드를 지켜보면서 코드의 어느 줄이 실행되지 않았는지 알려준다. 하지만 100% 커버리지는 기대하지 말라. 코드 커버리지만 올리지 말고 상태 조합을 테스트하라. 

* 버그는 한 번만 잡아라. 버그가 기존 테스트의 그물을 빠져나갔따면 다음번에는 그걸 잡아낼 수 있도록 새 테스트를 추가해야 한다. 

### 1-4. 사용자를 기쁘게 하라
* 개발자로서 우리의 목표는 사용자를 기쁘게 하는 것이다. 여러분의 사용자가 기대하는 것은 소프트웨어와 관련이 없다. 그러면 어떻게 사용자들이 기대하는 것을 밝혀낼 수 있을까?

### 1-5. 오만과 편견 
* 실용주의 프로그래머는 책임을 회피하지 않는다. 그 대신 도전을 수용하고 자신의 전문성이 널리 알려지는 것을 기뻐한다. 설계 혹은 코드를 맡는다면 자신이 보기에 자랑스러운 작품을 만들어 낼 것이다. 옛 장인들은 자신의 작품에 서명하는 것을 자랑스러워 했다. 여러분도 그래야 한다. 


## 2. 소감
책에서 초반에 중요하게 다루었던 부분이 프로그래머가 속해있는 그 팀 자체에도 적용되어야 한다는 것으로 중요성을 다시 한 번 일깨우고 책은 마무리한다. 테스트코드를 작성에 대해 다시 한 번 강조하면서, 품질은 애초에 포함된 것이지 나중에 덧붙이는 것이 아니라고 하는 점이 인상적이었다. 일하다보면 때로 완성도와 품질에 대해 잊어버릴 때가 있다. 내가 몰랐던 일정이 예고없이 갑자기 정해져있고, 그 일정은 당장 며칠 남지 않았고 지금 할 일이 마무리되지 않았는데 재촉하듯 다시 한 번 강조할 때도 있다. 이럴 때면 사실 불편한 마음이 생기곤 한다. 나는 우리 팀의 일원이기도 하지만 우리 팀은 조직의 일원이기도 한데, 가끔 이렇게 유기적으로 움직이지 않을 때면 피로도가 많이 오른다. 그럴 때면 일단 "적당히 괜찮은 소프트웨어"에 대한 타협점을 떠올리게 된다. 이런 합의점들이 어렵다는 생각도 들었고, 현실에서 어떻게 실용주의적 태도를 이어갈 수 있을지에 대한 고민과 스스로에 대한 케어와 발전도 많이 필요할 것 같다. 이 책의 전체 내용을 완전히 이해하지 못했고, 많은 것들을 아직 체화하지도 못했다고 생각하지만 요즘 일할 때면 가끔 책의 문장들이 떠오를 때가 있는데 계속해서 떠올리다보면 조금씩 체화되지 않을까? 시간이 조금 더 지나서 이 책을 재독하면 또 다르게 읽혀질 수도 있을 것 같고, 그러면 좋을 것 같다. 